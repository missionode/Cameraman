<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="A simple and clean camera app.">
    <title>Camera</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <style>
        :root {
            --primary-color: #ffffff;
            --accent-color: #ffd700;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
            --blur-amount: 30px;
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        /* --- Viewfinder --- */
        #video,
        #canvas-output {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(1);
            /* Default mirrored handled in JS */
            transition: opacity 0.3s ease;
        }

        /* Hide video when canvas is being used for rendering */
        #video {
            opacity: 0;
            /* Hide raw video, show canvas */
        }

        #canvas-output {
            opacity: 1;
        }

        /* --- Dynamic Island (Top Bar) --- */
        .dynamic-island-container {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 100;
            pointer-events: none;
        }

        .dynamic-island {
            background: #000;
            border-radius: 35px;
            height: 35px;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            transition: all 0.5s var(--ease-out-expo);
            pointer-events: auto;
            color: white;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .dynamic-island.recording {
            width: 180px;
            background: rgba(40, 0, 0, 1);
        }

        .di-content {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
        }

        .di-indicator {
            width: 8px;
            height: 8px;
            background: #4cd964;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .dynamic-island.recording .di-indicator {
            background: #ff3b30;
            animation: pulse-red 2s infinite;
        }

        .di-timer {
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.5px;
        }

        /* --- Floating Controls (Side Islands) --- */
        .top-controls {
            position: absolute;
            top: 20px;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            z-index: 90;
            pointer-events: none;
        }

        .glass-pill {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--blur-amount));
            -webkit-backdrop-filter: blur(var(--blur-amount));
            border: 1px solid var(--glass-border);
            height: 44px;
            border-radius: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            pointer-events: auto;
            transition: transform 0.2s ease, background 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .glass-pill:active {
            transform: scale(0.96);
            background: rgba(40, 40, 40, 0.7);
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* --- Bottom Controls --- */
        .controls {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            padding: 0 30px;
        }

        .control-btn-secondary {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--blur-amount));
            -webkit-backdrop-filter: blur(var(--blur-amount));
            border: 1px solid var(--glass-border);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn-secondary:active {
            transform: scale(0.9);
            background: rgba(60, 60, 60, 0.6);
        }

        .control-btn-secondary svg {
            width: 22px;
            height: 22px;
            fill: white;
        }

        /* --- Shutter Button --- */
        #record-container {
            position: relative;
            width: 84px;
            height: 84px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #record {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            background: transparent;
            border: 4px solid white;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        #record .inner-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 58px;
            height: 58px;
            border-radius: 50%;
            background: #ff3b30;
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        #record.recording {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #record.recording .inner-circle {
            width: 28px;
            height: 28px;
            border-radius: 4px;
        }

        /* --- Focus & Zoom Sliders --- */
        .slider-container {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 200px;
            width: 40px;
            z-index: 95;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .slider-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        input[type=range][orient=vertical] {
            writing-mode: bt-lr;
            /* IE/Edge */
            -webkit-appearance: slider-vertical;
            /* WebKit */
            width: 8px;
            height: 100%;
            padding: 0 5px;
        }

        /* --- Panels & Modals --- */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .panel-overlay[style*="display: flex"] {
            opacity: 1;
        }

        .panel-content {
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            color: white;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        /* --- Animations --- */
        @keyframes pulse-red {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        /* --- Utilities --- */
        .hidden {
            display: none !important;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
        crossorigin="anonymous"></script>
</head>

<body>
    <div class="container" id="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas-output"></canvas>

        <!-- Dynamic Island (Top) -->
        <div class="dynamic-island-container">
            <div class="dynamic-island" id="dynamic-island">
                <div class="di-content">
                    <div class="di-indicator" id="di-indicator"></div>
                    <span id="di-status" style="font-size: 13px;">Ready</span>
                </div>
                <div class="di-content hidden" id="di-timer-container">
                    <span class="di-timer" id="di-timer">00:00</span>
                </div>
            </div>
        </div>

        <!-- Top Controls (Floating Glass) -->
        <div class="top-controls">
            <div class="glass-pill">
                <button class="icon-btn" id="handbook-btn" title="Handbook">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z" />
                    </svg>
                </button>
            </div>

            <div class="glass-pill">
                <button class="icon-btn" id="settings-btn" title="Settings">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Focus/Zoom Slider (Vertical Side) -->
        <div class="slider-container" id="focus-slider-container">
            <input type="range" id="focus-distance" min="0" max="1" step="0.01" orient="vertical">
        </div>

        <!-- Bottom Controls -->
        <div class="controls">
            <button class="control-btn-secondary" id="toggle-camera" title="Switch Camera">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5L18.5 12 15 15.5z" />
                </svg>
            </button>

            <div id="record-container" title="Record">
                <div id="record">
                    <div class="inner-circle"></div>
                </div>
            </div>

            <button class="control-btn-secondary" id="capture" title="Photo">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12 12c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm0-10c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z" />
                    <circle cx="12" cy="12" r="3" />
                </svg>
            </button>
        </div>

        <div class="toast" id="install-toast">
            <span>Install this app for the best experience!</span>
            <div class="toast-buttons">
                <button id="toast-dismiss-btn">Later</button>
                <button id="toast-install-btn">Install</button>
            </div>
        </div>
    </div>

    <!-- Handbook Panel -->
    <div class="panel-overlay" id="handbook-panel">
        <div class="panel-content">
            <button class="close-btn" id="close-handbook-btn">&times;</button>
            <h2>Filmmaking Handbook</h2>
            <div id="handbook-content-container"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="panel-overlay" id="settings-modal">
        <div class="panel-content">
            <button class="close-btn" id="close-settings-btn">&times;</button>
            <h2>Settings</h2>
            <div class="settings-group">
                <label for="aspect-ratio">Aspect Ratio</label>
                <select id="aspect-ratio"></select>
            </div>
            <div class="settings-group">
                <label for="color-grading">Color Grading</label>
                <select id="color-grading"></select>
            </div>
            <div class="settings-group" id="focus-control-group" style="display: none;">
                <label for="focus-mode">Focus Mode</label>
                <select id="focus-mode">
                    <option value="continuous">Continuous Autofocus</option>
                    <option value="manual">Manual</option>
                </select>
            </div>
            <div class="settings-group" id="video-stabilization-group" style="display: none;">
                <label for="video-stabilization">Video Stabilization</label>
                <select id="video-stabilization">
                    <option value="off">Off</option>
                    <option value="realtime">Real-time</option>
                    <option value="cinematic">Cinematic</option>
                </select>
            </div>
            <div class="settings-group" id="noise-suppression-group" style="display: none;">
                <label for="noise-suppression">
                    <input type="checkbox" id="noise-suppression">
                    Noise Suppression
                </label>
                <small>(Reduces background audio noise)</small>
            </div>
            <div class="settings-group">
                <label for="apply-grade-to-video">
                    <input type="checkbox" id="apply-grade-to-video">
                    Apply Grading to Video
                </label>
                <small>(May impact performance)</small>
            </div>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

        // --- CONFIGURATION ---
        const config = {
            aspectRatios: [
                { name: '16:9', value: 1.7777777778 },
                { name: '4:3', value: 1.3333333333 },
                { name: '2.39:1', value: 2.39 }
            ],
            colorGradings: [
                { name: 'None', value: 'none' },
                { name: 'Empuraan', value: 'empuraan' },
                { name: 'Meiyazhagan', value: 'meiyazhagan' },
                { name: 'KGF', value: 'kgf' },
                { name: 'Salaar', value: 'salaar' },
                { name: 'Noir', value: 'noir' },
                { name: 'Vintage', value: 'vintage' },
                { name: 'Bleach Bypass', value: 'bleach-bypass' },
                { name: 'Teal & Orange', value: 'teal-orange' },
                { name: 'Matrix', value: 'matrix' }
            ]
        };

        // --- DOM ELEMENTS ---
        const video = document.getElementById('video');
        const canvasOutput = document.getElementById('canvas-output'); // Display canvas
        const container = document.getElementById('container');

        // Dynamic Island
        const dynamicIsland = document.getElementById('dynamic-island');
        const diIndicator = document.getElementById('di-indicator');
        const diStatus = document.getElementById('di-status');
        const diTimer = document.getElementById('di-timer');
        const diTimerContainer = document.getElementById('di-timer-container');

        const toggleCameraButton = document.getElementById('toggle-camera');
        const captureButton = document.getElementById('capture');
        const recordContainer = document.getElementById('record-container');
        const recordBtnInner = document.querySelector('#record');

        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const aspectRatioSelect = document.getElementById('aspect-ratio');
        const colorGradingSelect = document.getElementById('color-grading');
        const applyGradeCheckbox = document.getElementById('apply-grade-to-video');

        const handbookBtn = document.getElementById('handbook-btn');
        const handbookPanel = document.getElementById('handbook-panel');
        const closeHandbookBtn = document.getElementById('close-handbook-btn');
        const handbookContentContainer = document.getElementById('handbook-content-container');

        const videoStabilizationGroup = document.getElementById('video-stabilization-group');
        const videoStabilizationSelect = document.getElementById('video-stabilization');
        const focusControlGroup = document.getElementById('focus-control-group');
        const focusModeSelect = document.getElementById('focus-mode');
        const focusSliderContainer = document.getElementById('focus-slider-container');
        const focusDistanceSlider = document.getElementById('focus-distance');
        const noiseSuppressionGroup = document.getElementById('noise-suppression-group');
        const noiseSuppressionCheckbox = document.getElementById('noise-suppression');

        const installToast = document.getElementById('install-toast');
        const toastInstallBtn = document.getElementById('toast-install-btn');
        const toastDismissBtn = document.getElementById('toast-dismiss-btn');

        // --- APP STATE ---
        let stream = null;
        let currentFacingMode = 'user'; // Default to user for Center Stage demo
        let currentAspectRatio = config.aspectRatios[0].value;
        let currentStabilizationMode = 'off';
        let currentFocusMode = 'continuous';
        let currentFocusDistance = 0;
        let enableNoiseSuppression = false;
        let applyGradeToVideo = true; // Default to true for the new canvas workflow
        let handbookContentLoaded = false;
        let optimalBitrate = 10000000;
        let uiTimeout = null;
        let deferredPrompt = null;
        let wakeLock = null;

        // --- CENTER STAGE STATE ---
        let centerStageEnabled = false;
        let faceLandmarker = null;
        let lastVideoTime = -1;
        let faces = [];
        let currentCrop = { x: 0, y: 0, width: 1, height: 1 }; // Normalized (0-1)
        let targetCrop = { x: 0, y: 0, width: 1, height: 1 };

        // --- REAL-TIME PROCESSING STATE ---
        let canvasCtx = canvasOutput.getContext('2d', { willReadFrequently: false, alpha: false });
        let destinationStream, canvasLoopId = null;

        // --- VIDEO RECORDING STATE ---
        let mediaRecorder = null;
        let isRecording = false;
        let recordingStartTime = null;
        let recordingInterval = null;
        let fileHandle = null;
        let recorderWorker = null;

        // --- INITIALIZATION ---
        async function init() {
            try {
                // Initialize Worker
                recorderWorker = new Worker('recorder.worker.js');
                recorderWorker.onmessage = (event) => {
                    if (event.data.type === 'closed') {
                        updateDynamicIsland('Success', 'Video Saved', 'green');
                        setTimeout(() => updateDynamicIsland('Ready', '', 'green'), 3000);
                        fileHandle = null;
                    } else if (event.data.type === 'error') {
                        console.error('Worker error:', event.data.error);
                        updateDynamicIsland('Error', 'Save Failed', 'red');
                    }
                };

                detectAndApplyDefaults();
                populateSelectOptions();

                // Init MediaPipe asynchronously
                setupCenterStage();

                await startCamera();
                setupPWA();
                setupUIHide();
                setupSettings();
                setupHandbook();
                setupWakeLock();
                startCanvasLoop(); // Always run canvas loop now
            } catch (error) {
                console.error('Error initializing:', error);
                updateDynamicIsland('Error', 'Init Failed', 'red');
            }
        }

        async function setupCenterStage() {
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numFaces: 2
                });

                // Add toggle to settings
                const div = document.createElement('div');
                div.className = 'settings-group';
                div.innerHTML = `
                    <label for="center-stage-toggle">
                        <input type="checkbox" id="center-stage-toggle">
                        Center Stage
                    </label>
                    <small>Auto-zoom to keep you in frame</small>
                `;
                // Insert after Aspect Ratio
                aspectRatioSelect.closest('.settings-group').after(div);

                const toggle = document.getElementById('center-stage-toggle');
                toggle.addEventListener('change', () => {
                    centerStageEnabled = toggle.checked;
                    if (!centerStageEnabled) {
                        targetCrop = { x: 0, y: 0, width: 1, height: 1 }; // Reset zoom
                    }
                });

                console.log("Center Stage initialized");
            } catch (e) {
                console.error("Failed to load Center Stage:", e);
            }
        }

        // --- CANVAS RENDER LOOP (The Heart of the App) ---
        function startCanvasLoop() {
            const lerp = (start, end, factor) => start + (end - start) * factor;

            async function render() {
                if (!video || video.paused || video.ended) {
                    canvasLoopId = requestAnimationFrame(render);
                    return;
                }

                // Resize canvas if needed
                if (canvasOutput.width !== video.videoWidth || canvasOutput.height !== video.videoHeight) {
                    canvasOutput.width = video.videoWidth;
                    canvasOutput.height = video.videoHeight;
                }

                // 1. Center Stage Logic
                if (centerStageEnabled && faceLandmarker && video.currentTime !== lastVideoTime) {
                    let startTimeMs = performance.now();
                    const results = faceLandmarker.detectForVideo(video, startTimeMs);
                    lastVideoTime = video.currentTime;

                    if (results.detections.length > 0) {
                        // Calculate bounding box for all faces
                        let minX = 1, minY = 1, maxX = 0, maxY = 0;
                        results.detections.forEach(det => {
                            const box = det.boundingBox; // In pixels
                            const normX = box.originX / video.videoWidth;
                            const normY = box.originY / video.videoHeight;
                            const normW = box.width / video.videoWidth;
                            const normH = box.height / video.videoHeight;

                            if (normX < minX) minX = normX;
                            if (normY < minY) minY = normY;
                            if (normX + normW > maxX) maxX = normX + normW;
                            if (normY + normH > maxY) maxY = normY + normH;
                        });

                        // Add padding (20%)
                        const padding = 0.2;
                        minX = Math.max(0, minX - padding);
                        minY = Math.max(0, minY - padding);
                        maxX = Math.min(1, maxX + padding);
                        maxY = Math.min(1, maxY + padding);

                        // Calculate target rect
                        let w = maxX - minX;
                        let h = maxY - minY;

                        // Enforce aspect ratio of the video
                        const currentScreenAspect = video.videoWidth / video.videoHeight;
                        const targetBoxWidth = w * video.videoWidth;
                        const targetBoxHeight = h * video.videoHeight;

                        let finalW = targetBoxWidth;
                        let finalH = targetBoxHeight;

                        if (targetBoxWidth / targetBoxHeight > currentScreenAspect) {
                            // Wider than screen, fit by width
                            finalH = targetBoxWidth / currentScreenAspect;
                        } else {
                            // Taller, fit by height
                            finalW = targetBoxHeight * currentScreenAspect;
                        }

                        // Normalize back
                        w = finalW / video.videoWidth;
                        h = finalH / video.videoHeight;

                        // Recenter
                        const centerX = (minX + maxX) / 2;
                        const centerY = (minY + maxY) / 2;

                        targetCrop = {
                            x: Math.max(0, Math.min(1 - w, centerX - w / 2)),
                            y: Math.max(0, Math.min(1 - h, centerY - h / 2)),
                            width: w,
                            height: h
                        };

                    } else {
                        // No face? slowly zoom out
                        targetCrop = { x: 0, y: 0, width: 1, height: 1 };
                    }
                }

                // Smoothly interpolate currentCrop -> targetCrop
                const smoothFactor = 0.05; // Adjust for speed
                currentCrop.x = lerp(currentCrop.x, targetCrop.x, smoothFactor);
                currentCrop.y = lerp(currentCrop.y, targetCrop.y, smoothFactor);
                currentCrop.width = lerp(currentCrop.width, targetCrop.width, smoothFactor);
                currentCrop.height = lerp(currentCrop.height, targetCrop.height, smoothFactor);

                // 2. Draw to Canvas
                let sx = currentCrop.x * video.videoWidth;
                let sy = currentCrop.y * video.videoHeight;
                let sw = currentCrop.width * video.videoWidth;
                let sh = currentCrop.height * video.videoHeight;

                // Safety checks
                if (sw <= 0) sw = video.videoWidth;
                if (sh <= 0) sh = video.videoHeight;

                // Draw Base Video
                canvasCtx.globalCompositeOperation = 'source-over';

                // Handle mirroring
                canvasCtx.save();
                if (currentFacingMode === 'user') {
                    canvasCtx.translate(canvasOutput.width, 0);
                    canvasCtx.scale(-1, 1);
                }

                canvasCtx.drawImage(video, sx, sy, sw, sh, 0, 0, canvasOutput.width, canvasOutput.height);
                canvasCtx.restore();

                // 3. Apply Color Grading (Optimized Canvas Layers)
                const currentGrade = colorGradingSelect.value;
                if (currentGrade !== 'none') {
                    applyCanvasGrading(canvasCtx, canvasOutput.width, canvasOutput.height, currentGrade);
                }

                canvasLoopId = requestAnimationFrame(render);
            }
            canvasLoopId = requestAnimationFrame(render);
        }

        // --- UI FUNCTIONS ---
        function updateDynamicIsland(status, secondaryText = '', color = 'green') {
            diStatus.textContent = status;
            diIndicator.style.background = color === 'red' ? '#ff3b30' : '#4cd964';

            if (secondaryText) {
                diStatus.textContent = `${status} | ${secondaryText}`;
            }
        }

        // --- CORE FUNCTIONS (Updated for UI) ---

        // Start Camera
        async function startCamera() {
            updateDynamicIsland('Starting Camera...');
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    width: { ideal: 4096 },
                    height: { ideal: 2160 },
                    aspectRatio: { ideal: currentAspectRatio },
                    facingMode: currentFacingMode
                },
                audio: { noiseSuppression: enableNoiseSuppression }
            };

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                // Setup stream for recording (Canvas Stream)
                const canvasStream = canvasOutput.captureStream(30);
                const audioTrack = stream.getAudioTracks()[0];
                destinationStream = new MediaStream([...canvasStream.getVideoTracks(), ...(audioTrack ? [audioTrack] : [])]);

                updateDynamicIsland('Ready');
            } catch (error) {
                console.error("Camera Error", error);
                updateDynamicIsland('Error', 'Camera Failed', 'red');
            }
        }

        // Start Recording
        async function startRecording() {
            try {
                if (!('showSaveFilePicker' in window)) return alert('Browser not supported');

                updateDynamicIsland('Setup', 'Choosing File...');
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: `CS-Video-${Date.now()}.webm`,
                    types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
                });

                // Transfer to worker
                const writable = await fileHandle.createWritable();
                recorderWorker.postMessage({ type: 'init', payload: { writableStream: writable } }, [writable]);

                const options = { mimeType: 'video/webm; codecs=vp9,opus', videoBitsPerSecond: optimalBitrate };
                mediaRecorder = new MediaRecorder(destinationStream, options);

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recorderWorker.postMessage({ type: 'write', payload: { data: e.data } });
                };

                mediaRecorder.onstop = () => recorderWorker.postMessage({ type: 'close' });

                mediaRecorder.start(1000); // 1s chunks

                isRecording = true;
                recordingStartTime = Date.now();

                // UI Updates
                dynamicIsland.classList.add('recording');
                diTimerContainer.classList.remove('hidden');
                recordBtnInner.classList.add('recording');
                updateRecordingTimer();
                updateDynamicIsland('Recording', '', 'red');

            } catch (err) {
                console.error(err);
                if (err.name !== 'AbortError') updateDynamicIsland('Error', 'Rec Failed', 'red');
                else updateDynamicIsland('Ready');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;

                dynamicIsland.classList.remove('recording');
                diTimerContainer.classList.add('hidden');
                recordBtnInner.classList.remove('recording');
                clearTimeout(recordingInterval);
                updateDynamicIsland('Saving...', '', 'green');
            }
        }

        function updateRecordingTimer() {
            if (!isRecording) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            diTimer.textContent = `${minutes}:${seconds}`;
            recordingInterval = setTimeout(updateRecordingTimer, 1000);
        }

        // --- Event Listeners ---
        recordContainer.addEventListener('click', async () => {
            if (!stream) return;
            if (!isRecording) await startRecording();
            else stopRecording();
        });

        toggleCameraButton.addEventListener('click', async () => {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            await startCamera();
        });

        // --- REUSE EXISTING HELPER FUNCTIONS ---
        function detectAndApplyDefaults() {
            const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();

            if (supportedConstraints.noiseSuppression) {
                console.log('Noise suppression supported. Enabling by default.');
                enableNoiseSuppression = true;
                noiseSuppressionCheckbox.checked = true;
                noiseSuppressionGroup.style.display = 'block';
            }
            if (supportedConstraints.videoStabilizationMode) {
                console.log('Video stabilization control is supported.');
                videoStabilizationGroup.style.display = 'block';
            }
            if (supportedConstraints.focusMode && supportedConstraints.focusDistance) {
                console.log('Focus control is supported.');
                focusControlGroup.style.display = 'block';
                focusSliderContainer.classList.add('supported');
            }
        }
        function populateSelectOptions() {
            config.aspectRatios.forEach(ratio => {
                const option = document.createElement('option');
                option.value = ratio.value;
                option.textContent = ratio.name;
                aspectRatioSelect.appendChild(option);
            });
            aspectRatioSelect.value = currentAspectRatio;

            config.colorGradings.forEach(grade => {
                const option = document.createElement('option');
                option.value = grade.value;
                option.textContent = grade.name;
                colorGradingSelect.appendChild(option);
            });
        }
        function setupUIHide() {
            container.addEventListener('mousemove', showUI);
            container.addEventListener('touchstart', showUI);
            hideUIAfterTimeout();
        }

        function showUI() {
            container.classList.remove('ui-hidden');
            clearTimeout(uiTimeout);
            hideUIAfterTimeout();
        }

        function hideUIAfterTimeout() {
            uiTimeout = setTimeout(() => {
                if (!isRecording) { // Don't hide controls while recording
                    container.classList.add('ui-hidden');
                }
            }, 4000);
        }
        function setupPWA() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installToast.classList.add('visible');
            });

            toastInstallBtn.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    installToast.classList.remove('visible');
                }
                deferredPrompt = null;
            });

            toastDismissBtn.addEventListener('click', () => {
                installToast.classList.remove('visible');
            });

            if (window.matchMedia('(display-mode: standalone)').matches) {
                installToast.style.display = 'none';
            }
        }
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock was released');
                    });
                    console.log('Screen Wake Lock is active');
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                }
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLock !== null) {
                await wakeLock.release();
                wakeLock = null;
            }
        };

        function setupWakeLock() {
            requestWakeLock();
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    await requestWakeLock();
                } else {
                    await releaseWakeLock();
                }
            });
        }
        function setupSettings() {
            // Re-attach settings listeners
            settingsBtn.addEventListener('click', () => settingsModal.style.display = 'flex');
            closeSettingsBtn.addEventListener('click', () => settingsModal.style.display = 'none');
            settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) settingsModal.style.display = 'none'; });

            aspectRatioSelect.addEventListener('change', async () => {
                currentAspectRatio = parseFloat(aspectRatioSelect.value);
                await startCamera();
            });
            // Color Grading handled in canvas loop
        }
        function setupHandbook() {
            handbookBtn.addEventListener('click', async () => {
                if (!handbookContentLoaded) {
                    try {
                        const response = await fetch('handbook.json');
                        const data = await response.json();
                        populateHandbook(data);
                        handbookContentLoaded = true;
                    } catch (e) { }
                }
                handbookPanel.style.display = 'flex';
            });
            closeHandbookBtn.addEventListener('click', () => handbookPanel.style.display = 'none');
        }
        function populateHandbook(data) {
            handbookContentContainer.innerHTML = '';
            data.categories.forEach(cat => {
                const d = document.createElement('details');
                const s = document.createElement('summary');
                s.textContent = cat.title;
                const div = document.createElement('div');
                div.className = 'handbook-entry';
                cat.entries.forEach(entry => {
                    const h = document.createElement('h4'); h.textContent = entry.name;
                    const p = document.createElement('p'); p.textContent = entry.description;
                    div.append(h, p);
                });
                d.append(s, div);
                handbookContentContainer.append(d);
            });
        }

        // Canvas Grading Helpers
        const gradingDefinitions = {
            'noir': [{ mode: 'saturation', color: '#000000' }, { mode: 'overlay', color: 'rgba(0,0,0,0.4)' }, { mode: 'multiply', color: 'rgba(0,0,0,0.2)' }],
            'vintage': [{ mode: 'color', color: 'rgba(112, 66, 20, 0.4)' }, { mode: 'soft-light', color: 'rgba(255, 240, 200, 0.3)' }, { mode: 'multiply', color: 'rgba(255, 255, 255, 0.1)' }],
            'bleach-bypass': [{ mode: 'saturation', color: '#555555' }, { mode: 'overlay', color: 'rgba(255,255,255,0.3)' }, { mode: 'multiply', color: 'rgba(0,0,0,0.3)' }],
            'teal-orange': [{ mode: 'overlay', gradient: { stops: [[0, 'rgba(0, 128, 128, 0.6)'], [1, 'rgba(255, 165, 0, 0.6)']], type: 'linear' } }],
            'matrix': [{ mode: 'saturation', color: '#000000' }, { mode: 'overlay', color: '#00ff00' }, { mode: 'multiply', color: 'rgba(0, 50, 0, 0.4)' }],
            'kgf': [{ mode: 'color', color: 'rgba(180, 140, 60, 0.5)' }, { mode: 'multiply', color: 'rgba(20, 10, 0, 0.4)' }, { mode: 'overlay', color: 'rgba(200, 150, 50, 0.2)' }],
            'salaar': [{ mode: 'saturation', color: '#333333' }, { mode: 'multiply', color: 'rgba(20, 30, 40, 0.5)' }, { mode: 'hard-light', color: 'rgba(0, 0, 0, 0.3)' }],
            'empuraan': [{ mode: 'multiply', color: 'rgba(50, 20, 10, 0.5)' }, { mode: 'overlay', color: 'rgba(255, 100, 50, 0.4)' }, { mode: 'saturation', color: 'rgba(255, 100, 50, 0.5)' }],
            'meiyazhagan': [{ mode: 'soft-light', color: 'rgba(255, 240, 220, 0.3)' }, { mode: 'screen', color: 'rgba(255, 200, 150, 0.1)' }]
        };

        function applyCanvasGrading(ctx, width, height, gradeName) {
            const layers = gradingDefinitions[gradeName];
            if (!layers) return;
            layers.forEach(layer => {
                ctx.globalCompositeOperation = layer.mode;
                if (layer.gradient) {
                    const grad = ctx.createLinearGradient(0, 0, width, height);
                    layer.gradient.stops.forEach(stop => grad.addColorStop(stop[0], stop[1]));
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = layer.color;
                }
                ctx.fillRect(0, 0, width, height);
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        // Initialize
        window.addEventListener('load', init);
    </script>
</body>

</html>