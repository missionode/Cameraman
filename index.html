<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Professional Centre Stage Camera with AI face tracking">
    <title>Centre Stage Camera</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Outer Frame - Fixed to device dimensions */
        .outer-frame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            z-index: 1;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            background: #000;
            transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .crosshair {
            position: absolute;
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            opacity: 0.9;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            transform: translateX(-50%);
        }

        .crosshair .dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair.locked {
            opacity: 1;
            z-index: 10;
        }

        .crosshair.locked::before, 
        .crosshair.locked::after {
            background: #48bb78;
        }

        .crosshair.locked .dot {
            background: #48bb78;
        }

        .center-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 3;
            pointer-events: none;
            opacity: 0.7;
        }

        .center-guide::before, .center-guide::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }

        .center-guide::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .center-guide::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }

        /* Controls always visible */
        .controls {
            position: absolute;
            bottom: 60px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 25px;
            z-index: 10;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.7rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            outline: none;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn.recording {
            background: rgba(220, 53, 69, 0.3);
            animation: pulse-red 2s infinite;
        }

        .status-bar {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .status {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e53e3e;
        }

        .status-dot.active {
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(220, 53, 69, 0.8);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            font-weight: 500;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: pulse 1.5s infinite;
        }

        /* Countdown overlay */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            font-size: 8rem;
            font-weight: bold;
            color: white;
            display: none;
        }

        /* Thumbnails container */
        .locked-faces-container {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 10px;
            border-radius: 15px;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 150px;
            justify-content: flex-end;
        }

        .locked-face-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .locked-face-thumbnail:hover {
            border-color: #48bb78;
            transform: scale(1.05);
        }

        .face-count {
            position: absolute;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        .tracking-mode {
            position: absolute;
            top: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        .camera-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
            
            .status {
                padding: 10px 20px;
                font-size: 0.8rem;
            }
            
            .locked-faces-container {
                top: 120px;
                right: 10px;
                max-width: 130px;
            }
            
            .locked-face-thumbnail {
                width: 50px;
                height: 50px;
            }
            
            .face-count, .tracking-mode, .camera-indicator {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .countdown-overlay {
                font-size: 6rem;
            }
        }
    </style>
</head>
<body>
    <!-- Outer Frame - Fixed to device dimensions -->
    <div class="outer-frame" id="outer-frame">
        <video id="video" autoplay playsinline muted></video>
        <div id="overlay"></div>
        <div class="center-guide"></div>
        
        <!-- Countdown Overlay -->
        <div class="countdown-overlay" id="countdown-overlay"></div>
        
        <div class="status-bar">
            <div class="status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
        
        <div class="recording-indicator" id="recording-indicator" style="display: none;">
            <div class="recording-dot"></div>
            <span id="recording-timer">Recording 00:00</span>
        </div>
        
        <div class="camera-indicator">
            <span id="camera-mode">Front Camera - Face Marking Mode</span>
        </div>
        
        <div class="face-count">
            <span id="face-count">Faces: 0</span>
        </div>
        
        <div class="tracking-mode">
            <span id="tracking-mode">Tap faces to mark them</span>
        </div>
        
        <div class="locked-faces-container" id="locked-faces-container" style="display: none;">
            <!-- Locked face thumbnails will be added here -->
        </div>
        
        <!-- Controls always visible -->
        <div class="controls">
            <button class="control-btn" id="toggle-camera">
                <span>üîÑ</span>
            </button>
            <button class="control-btn" id="capture">
                <span>üì∏</span>
            </button>
            <button class="control-btn" id="record">
                <span>‚è∫Ô∏è</span>
            </button>
        </div>
        
        <!-- Hidden canvas for recording -->
        <canvas id="recording-canvas" style="display: none;"></canvas>
    </div>

    <script>
        // DOM elements
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const outerFrame = document.getElementById('outer-frame');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const faceCount = document.getElementById('face-count');
        const trackingMode = document.getElementById('tracking-mode');
        const cameraMode = document.getElementById('camera-mode');
        const toggleCameraButton = document.getElementById('toggle-camera');
        const captureButton = document.getElementById('capture');
        const recordButton = document.getElementById('record');
        const recordingIndicator = document.getElementById('recording-indicator');
        const recordingTimer = document.getElementById('recording-timer');
        const lockedFacesContainer = document.getElementById('locked-faces-container');
        const recordingCanvas = document.getElementById('recording-canvas');
        const recordingCtx = recordingCanvas.getContext('2d');
        const countdownOverlay = document.getElementById('countdown-overlay');

        // App state
        let stream = null;
        let model = null;
        let isTracking = false;
        let animationId = null;
        let currentZoom = 1;
        let targetZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let targetPanX = 0;
        let targetPanY = 0;
        let isFrontCamera = true; // Start with front camera

        // Video recording state
        let mediaRecorder = null;
        let isRecording = false;
        let recordingStartTime = null;
        let recordingInterval = null;
        let fileHandle = null;
        let writableStream = null;

        // Face locking system
        let lockedFaces = new Map();
        let nextFaceId = 1;
        const MAX_LOCKED_FACES = 10;

        // Face tracking stabilization
        let facePositions = new Map();
        const FACE_SMOOTHING = 0.7;

        // Performance optimization
        let detectionFrameSkip = 0;
        const DETECTION_INTERVAL = 3;

        // Audio context for beep sounds
        let audioContext = null;

        // Initialize the app
        async function init() {
            try {
                statusText.textContent = 'Loading AI model...';
                
                // Load the BlazeFace model for face detection
                model = await blazeface.load();
                statusText.textContent = 'AI model loaded';
                
                // Start with front camera for face marking
                await startCamera(true);
                
                // Start face detection
                startFaceDetection();
                
                // Initialize audio context for beep sounds
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
            } catch (error) {
                console.error('Error initializing app:', error);
                statusText.textContent = 'Error initializing app';
            }
        }

        // Play beep sound
        function playBeep(frequency = 800, duration = 200) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        // Start camera with specified facing mode
        async function startCamera(useFrontCamera = true) {
            try {
                statusText.textContent = 'Starting camera...';
                
                // Stop existing stream if any
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                // Set up audio constraints with noise suppression
                const audioConstraints = {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 16000,
                    channelCount: 1
                };
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Use balanced quality settings
                const videoConstraints = {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 },
                    facingMode: useFrontCamera ? 'user' : 'environment'
                };
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: videoConstraints,
                    audio: audioConstraints
                });
                
                video.srcObject = stream;
                video.muted = true;
                isFrontCamera = useFrontCamera;
                
                // Reset transformations
                currentZoom = 1;
                targetZoom = 1;
                currentPanX = 0;
                targetPanX = 0;
                currentPanY = 0;
                targetPanY = 0;
                video.style.transform = 'scale(1) translate(0%, 0%)';
                
                // Clear face positions when switching cameras
                facePositions.clear();
                
                // Update UI based on camera mode
                cameraMode.textContent = useFrontCamera ? 'Front Camera - Face Marking Mode' : 'Rear Camera - Recording Mode';
                
                // Disable recording for front camera
                recordButton.disabled = useFrontCamera;
                if (useFrontCamera) {
                    recordButton.title = 'Switch to rear camera to record';
                    trackingMode.textContent = 'Tap faces to mark them';
                } else {
                    recordButton.title = 'Start recording';
                    trackingMode.textContent = lockedFaces.size > 0 ? 
                        `Tracking ${lockedFaces.size} marked face${lockedFaces.size > 1 ? 's' : ''}` : 
                        'Auto tracking all faces';
                }
                
                statusText.textContent = `Camera active - ${useFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                statusDot.classList.add('active');
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                statusText.textContent = 'Camera access denied';
            }
        }

        // Toggle between front and rear cameras
        async function toggleCamera() {
            if (!stream) return;
            
            // Stop current recording if active
            if (isRecording) {
                stopRecording();
            }
            
            // Switch to opposite camera
            await startCamera(!isFrontCamera);
        }

        // Start face detection loop
        function startFaceDetection() {
            if (!model) return;
            
            isTracking = true;
            detectFaces();
        }

        // Get smoothed face position
        function getSmoothedPosition(faceId, currentX, currentY) {
            if (!facePositions.has(faceId)) {
                facePositions.set(faceId, { x: currentX, y: currentY });
                return { x: currentX, y: currentY };
            }
            
            const prev = facePositions.get(faceId);
            const smoothedX = prev.x * FACE_SMOOTHING + currentX * (1 - FACE_SMOOTHING);
            const smoothedY = prev.y * FACE_SMOOTHING + currentY * (1 - FACE_SMOOTHING);
            
            facePositions.set(faceId, { x: smoothedX, y: smoothedY });
            return { x: smoothedX, y: smoothedY };
        }

        // Intelligent framing algorithm - FIXED Centre Stage
        function calculateOptimalFraming(faces) {
            if (faces.length === 0) return { zoom: 1, panX: 0, panY: 0 };
            
            // Calculate bounding box of all faces
            let bounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity
            };
            
            faces.forEach(face => {
                // Calculate full body bounds (more conservative)
                const bodyHeight = face.height * 3.5;
                const bodyWidth = face.width * 1.8;
                const bodyX = face.x - bodyWidth / 2;
                const bodyY = face.y - bodyHeight / 3;
                const bodyMaxX = bodyX + bodyWidth;
                const bodyMaxY = bodyY + bodyHeight;
                
                bounds.minX = Math.min(bounds.minX, bodyX);
                bounds.maxX = Math.max(bounds.maxX, bodyMaxX);
                bounds.minY = Math.min(bounds.minY, bodyY);
                bounds.maxY = Math.max(bounds.maxY, bodyMaxY);
            });
            
            // Calculate center of the group
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            // Calculate required zoom to fit all bodies
            const boundsWidth = bounds.maxX - bounds.minX;
            const boundsHeight = bounds.maxY - bounds.minY;
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            // Calculate zoom needed to fit the group with comfortable padding
            const zoomX = videoWidth / (boundsWidth * 1.3);
            const zoomY = videoHeight / (boundsHeight * 1.3);
            let zoom = Math.min(zoomX, zoomY, 1.8);
            
            // More conservative zoom for multiple people
            if (faces.length > 1) {
                zoom = Math.min(zoom, 1.5);
            }
            
            // Ensure we don't zoom in too much
            zoom = Math.max(0.7, Math.min(1.8, zoom));
            
            // Calculate pan to center the group
            const videoCenterX = videoWidth / 2;
            const videoCenterY = videoHeight / 2;
            const offsetX = centerX - videoCenterX;
            const offsetY = centerY - videoCenterY;
            const panX = -offsetX / videoCenterX;
            const panY = -offsetY / videoCenterY;
            
            return {
                zoom: zoom,
                panX: Math.max(-0.7, Math.min(0.7, panX)),
                panY: Math.max(-0.7, Math.min(0.7, panY))
            };
        }

        // Detect faces and adjust frame - FIXED floating crosshairs
        async function detectFaces() {
            if (!isTracking || !model) return;
            
            detectionFrameSkip = (detectionFrameSkip + 1) % DETECTION_INTERVAL;
            if (detectionFrameSkip !== 0) {
                animationId = requestAnimationFrame(detectFaces);
                return;
            }
            
            try {
                const predictions = await model.estimateFaces(video, false);
                
                faceCount.textContent = `Faces: ${predictions.length}`;
                overlay.innerHTML = '';
                
                if (predictions.length > 0) {
                    let faces = [];
                    
                    predictions.forEach((prediction, index) => {
                        const [x, y, width, height] = [
                            prediction.topLeft[0],
                            prediction.topLeft[1],
                            prediction.bottomRight[0] - prediction.topLeft[0],
                            prediction.bottomRight[1] - prediction.topLeft[1]
                        ];
                        
                        // Calculate center of face
                        const centerX = x + width / 2;
                        const centerY = y + height / 2;
                        
                        // Get smoothed position for stable crosshair
                        const faceId = `${index}-${centerX.toFixed(0)}-${centerY.toFixed(0)}`;
                        const smoothedPos = getSmoothedPosition(faceId, centerX, centerY);
                        
                        faces.push({ 
                            x: smoothedPos.x, 
                            y: smoothedPos.y, 
                            width, 
                            height, 
                            index 
                        });
                        
                        // ONLY show crosshairs in front camera for manual marking
                        if (isFrontCamera) {
                            // Check if this face is already locked
                            const isLocked = Array.from(lockedFaces.values()).some(face => 
                                Math.abs(face.data.centerX - smoothedPos.x) < 50 && 
                                Math.abs(face.data.centerY - smoothedPos.y) < 50
                            );
                            
                            const crosshair = document.createElement('div');
                            crosshair.className = isLocked ? 'crosshair locked' : 'crosshair';
                            crosshair.style.left = `${smoothedPos.x}px`;
                            crosshair.style.top = `${smoothedPos.y}px`;
                            
                            const dot = document.createElement('div');
                            dot.className = 'dot';
                            crosshair.appendChild(dot);
                            
                            // Only allow tapping to lock in front camera mode
                            if (!isLocked) {
                                crosshair.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    lockFace(smoothedPos.x, smoothedPos.y, width, height, index);
                                });
                            }
                            
                            overlay.appendChild(crosshair);
                        }
                    });
                    
                    // Apply Centre Stage framing (only for back camera)
                    if (!isFrontCamera && faces.length > 0) {
                        // Use locked faces if available, otherwise use all faces
                        const facesToFrame = lockedFaces.size > 0 ? 
                            faces.filter(face => {
                                return Array.from(lockedFaces.values()).some(lockedFace => 
                                    Math.abs(lockedFace.data.centerX - face.x) < 80 && 
                                    Math.abs(lockedFace.data.centerY - face.y) < 80
                                );
                            }) : 
                            faces;
                        
                        if (facesToFrame.length > 0) {
                            const framing = calculateOptimalFraming(facesToFrame);
                            targetZoom = framing.zoom;
                            targetPanX = framing.panX;
                            targetPanY = framing.panY;
                            
                            // Update tracking mode
                            trackingMode.textContent = lockedFaces.size > 0 ? 
                                `Tracking ${lockedFaces.size} marked face${lockedFaces.size > 1 ? 's' : ''}` : 
                                'Auto tracking all faces';
                        } else {
                            // No matching faces found, reset to default
                            targetZoom = 1;
                            targetPanX = 0;
                            targetPanY = 0;
                            trackingMode.textContent = 'No marked faces detected';
                        }
                    } else {
                        // Front camera or no faces: no zoom or pan
                        targetZoom = 1;
                        targetPanX = 0;
                        targetPanY = 0;
                    }
                    
                } else {
                    // No faces detected - reset to default view
                    targetZoom = 1;
                    targetPanX = 0;
                    targetPanY = 0;
                    if (!isFrontCamera) {
                        trackingMode.textContent = 'No faces detected';
                    }
                    // Clear face positions when no faces detected
                    facePositions.clear();
                }
                
                applySmoothTransitions();
                
            } catch (error) {
                console.error('Error detecting faces:', error);
            }
            
            animationId = requestAnimationFrame(detectFaces);
        }

        // Apply transitions - FIXED for stable video frame
        function applySmoothTransitions() {
            // Only apply transformations for back camera
            if (!isFrontCamera) {
                // Smooth transitions
                const zoomDiff = targetZoom - currentZoom;
                currentZoom += zoomDiff * 0.1;
                
                const panXDiff = targetPanX - currentPanX;
                const panYDiff = targetPanY - currentPanY;
                currentPanX += panXDiff * 0.1;
                currentPanY += panYDiff * 0.1;
                
                // Apply transformations with limits to prevent black borders
                const scale = Math.max(0.7, Math.min(1.8, currentZoom));
                const translateX = Math.max(-35, Math.min(35, currentPanX * 35));
                const translateY = Math.max(-35, Math.min(35, currentPanY * 35));
                
                video.style.transform = `scale(${scale}) translate(${translateX}%, ${translateY}%)`;
            } else {
                // Front camera: ensure no transformations
                video.style.transform = 'scale(1) translate(0%, 0%)';
            }
        }

        // Lock a face (manual marking) - FIXED thumbnail generation
        function lockFace(centerX, centerY, width, height, index) {
            // Only allow locking in front camera mode
            if (!isFrontCamera) return;
            
            if (lockedFaces.size >= MAX_LOCKED_FACES) {
                statusText.textContent = `Maximum ${MAX_LOCKED_FACES} faces can be marked`;
                setTimeout(() => {
                    statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                }, 2000);
                return;
            }
            
            const faceId = nextFaceId++;
            
            // Create thumbnail
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 100;
            canvas.height = 100;
            
            // Calculate face area for thumbnail
            const scale = 100 / Math.max(width * 1.5, height * 1.5);
            const thumbWidth = width * scale;
            const thumbHeight = height * scale;
            const thumbX = (100 - thumbWidth) / 2;
            const thumbY = (100 - thumbHeight) / 2;
            
            // Draw face with background
            context.fillStyle = '#000';
            context.fillRect(0, 0, 100, 100);
            context.drawImage(
                video,
                centerX - width / 2, centerY - height / 2, width, height,
                thumbX, thumbY, thumbWidth, thumbHeight
            );
            
            const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.9);
            
            const thumbnail = document.createElement('img');
            thumbnail.className = 'locked-face-thumbnail';
            thumbnail.src = thumbnailUrl;
            thumbnail.title = 'Click to remove';
            
            thumbnail.addEventListener('click', () => {
                unlockedFace(faceId);
            });
            
            lockedFaces.set(faceId, {
                data: { centerX, centerY, width, height, index },
                thumbnail: thumbnailUrl,
                element: thumbnail
            });
            
            lockedFacesContainer.appendChild(thumbnail);
            lockedFacesContainer.style.display = 'flex';
            
            statusText.textContent = 'Face marked! Switch to rear camera to record';
            setTimeout(() => {
                statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
            }, 2000);
            
            // Play confirmation sound
            playBeep(1000, 100);
        }

        // Unlock a face
        function unlockedFace(faceId) {
            const face = lockedFaces.get(faceId);
            if (face) {
                face.element.remove();
                lockedFaces.delete(faceId);
                
                if (lockedFaces.size === 0) {
                    lockedFacesContainer.style.display = 'none';
                    if (!isFrontCamera) {
                        trackingMode.textContent = 'Auto tracking all faces';
                    }
                } else if (!isFrontCamera) {
                    trackingMode.textContent = `Tracking ${lockedFaces.size} marked face${lockedFaces.size > 1 ? 's' : ''}`;
                }
                
                statusText.textContent = 'Face removed';
                setTimeout(() => {
                    statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                }, 2000);
            }
        }

        // Capture photo
        captureButton.addEventListener('click', () => {
            if (!stream) return;
            
            // Set canvas to outer frame dimensions
            recordingCanvas.width = outerFrame.clientWidth;
            recordingCanvas.height = outerFrame.clientHeight;
            
            // Draw exactly what's shown in viewfinder
            recordingCtx.save();
            if (!isFrontCamera) {
                recordingCtx.translate(recordingCanvas.width / 2, recordingCanvas.height / 2);
                recordingCtx.scale(currentZoom, currentZoom);
                recordingCtx.translate(currentPanX * 35, currentPanY * 35);
                recordingCtx.drawImage(
                    video, 
                    -recordingCanvas.width / 2, 
                    -recordingCanvas.height / 2, 
                    recordingCanvas.width, 
                    recordingCanvas.height
                );
            } else {
                recordingCtx.drawImage(video, 0, 0, recordingCanvas.width, recordingCanvas.height);
            }
            recordingCtx.restore();
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `centre-stage-photo-${timestamp}.png`;
            link.href = recordingCanvas.toDataURL('image/png', 0.95);
            link.click();
            
            statusText.textContent = 'Photo saved to Downloads';
            setTimeout(() => {
                statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
            }, 2000);
        });

        // 7-second countdown before recording
        async function startCountdown() {
            return new Promise((resolve) => {
                let count = 7;
                countdownOverlay.style.display = 'flex';
                countdownOverlay.textContent = count;
                
                playBeep(600, 500); // Initial beep
                
                const countdownInterval = setInterval(() => {
                    count--;
                    countdownOverlay.textContent = count;
                    playBeep(600, 500);
                    
                    if (count <= 0) {
                        clearInterval(countdownInterval);
                        countdownOverlay.style.display = 'none';
                        resolve();
                    }
                }, 1000);
            });
        }

        // Toggle recording - FIXED to show file save dialog
        recordButton.addEventListener('click', async () => {
            if (!stream) return;
            
            if (isFrontCamera) {
                statusText.textContent = 'Switch to rear camera to record';
                return;
            }
            
            if (!isRecording) {
                // First, ask for file save location
                if (!('showSaveFilePicker' in window)) {
                    statusText.textContent = 'File System Access API not supported';
                    return;
                }
                
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `centre-stage-video-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`,
                        types: [{
                            description: 'WebM Video',
                            accept: {'video/webm': ['.webm']}
                        }]
                    });
                    
                    // After file is selected, start countdown and recording
                    await startCountdown();
                    await startRecording();
                    
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('File picker error:', err);
                        statusText.textContent = 'Error selecting file location';
                    }
                    // User cancelled file picker
                    statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                }
            } else {
                stopRecording();
            }
        });

        // Start video recording - FIXED for direct file streaming
        async function startRecording() {
            if (isFrontCamera) {
                statusText.textContent = 'Recording disabled for front camera';
                return;
            }
            
            try {
                // Create writable stream to the selected file
                writableStream = await fileHandle.createWritable();
                
                video.muted = true;
                
                // Set up canvas for recording
                recordingCanvas.width = outerFrame.clientWidth;
                recordingCanvas.height = outerFrame.clientHeight;
                
                // Create canvas stream
                const canvasStream = recordingCanvas.captureStream(30);
                
                // Get audio track
                const audioTracks = stream.getAudioTracks();
                
                // Combine streams
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioTracks
                ]);
                
                // Quality recording settings
                const options = { 
                    mimeType: 'video/webm; codecs=vp9,opus',
                    videoBitsPerSecond: 30000000 // 30 Mbps for good quality/performance balance
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8,opus';
                    options.videoBitsPerSecond = 15000000; // 15 Mbps for VP8
                }
                
                mediaRecorder = new MediaRecorder(combinedStream, options);
                
                // Stream directly to file
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data && event.data.size > 0 && writableStream) {
                        try {
                            await writableStream.write(event.data);
                        } catch (error) {
                            console.error('Error writing to file:', error);
                            statusText.textContent = 'Error writing video file';
                            stopRecording();
                        }
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    if (writableStream) {
                        try {
                            await writableStream.close();
                            writableStream = null;
                            fileHandle = null;
                            
                            statusText.textContent = 'Video saved successfully';
                            setTimeout(() => {
                                statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                            }, 3000);
                        } catch (error) {
                            console.error('Error closing file:', error);
                            statusText.textContent = 'Error saving video file';
                        }
                    }
                    video.muted = false;
                };
                
                // Function to draw viewfinder content to canvas
                function drawToCanvas() {
                    if (!isRecording) return;
                    
                    recordingCtx.save();
                    recordingCtx.translate(recordingCanvas.width / 2, recordingCanvas.height / 2);
                    recordingCtx.scale(currentZoom, currentZoom);
                    recordingCtx.translate(currentPanX * 35, currentPanY * 35);
                    recordingCtx.drawImage(
                        video, 
                        -recordingCanvas.width / 2, 
                        -recordingCanvas.height / 2, 
                        recordingCanvas.width, 
                        recordingCanvas.height
                    );
                    recordingCtx.restore();
                    
                    requestAnimationFrame(drawToCanvas);
                }
                
                mediaRecorder.start(1000);
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Start drawing to canvas
                drawToCanvas();
                
                recordButton.classList.add('recording');
                recordButton.innerHTML = '<span>‚èπÔ∏è</span>';
                recordingIndicator.style.display = 'flex';
                
                updateRecordingTimer();
                
                statusText.textContent = 'Recording - Streaming to file';
                
            } catch (error) {
                console.error('Error starting recording:', error);
                statusText.textContent = 'Error starting recording';
                
                video.muted = false;
                if (writableStream) {
                    try {
                        await writableStream.close();
                    } catch (e) {}
                    writableStream = null;
                    fileHandle = null;
                }
            }
        }

        // Stop video recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                recordButton.classList.remove('recording');
                recordButton.innerHTML = '<span>‚è∫Ô∏è</span>';
                recordingIndicator.style.display = 'none';
                
                clearInterval(recordingInterval);
                
                video.muted = false;
            }
        }

        // Update recording timer
        function updateRecordingTimer() {
            if (!isRecording) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            recordingTimer.textContent = `Recording ${minutes}:${seconds}`;
            recordingInterval = setTimeout(updateRecordingTimer, 1000);
        }

        // Initialize the app
        window.addEventListener('load', init);

        // Set up camera toggle
        toggleCameraButton.addEventListener('click', toggleCamera);

        // Clean up
        window.addEventListener('beforeunload', () => {
            isTracking = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (isRecording) {
                stopRecording();
            }
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
        });
    </script>
</body>
</html>
