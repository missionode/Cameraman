<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Professional Centre Stage Camera with AI face tracking">
    <title>Centre Stage Camera</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            background: #000;
            transition: transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .crosshair {
            position: absolute;
            width: 50px;
            height: 50px;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            opacity: 0.9;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            transform: translateX(-50%);
        }

        .crosshair .dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .crosshair.locked {
            z-index: 10;
        }

        .crosshair.locked::before, 
        .crosshair.locked::after {
            background: #48bb78;
            height: 3px;
            width: 3px;
        }

        .crosshair.locked .dot {
            background: #48bb78;
            width: 10px;
            height: 10px;
        }

        .center-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 3;
            pointer-events: none;
            opacity: 0.7;
        }

        .center-guide::before, .center-guide::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }

        .center-guide::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .center-guide::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 25px;
            z-index: 10;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.7rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            outline: none;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn.recording {
            background: rgba(220, 53, 69, 0.3);
            animation: pulse-red 2s infinite;
        }

        .status-bar {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .status {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e53e3e;
        }

        .status-dot.active {
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .pwa-install {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 18px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .pwa-install:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(220, 53, 69, 0.8);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            font-weight: 500;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: pulse 1.5s infinite;
        }

        .locked-faces-container {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 10px;
            border-radius: 15px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 120px;
        }

        .locked-face-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .locked-face-thumbnail:hover {
            border-color: #48bb78;
            transform: scale(1.05);
        }

        .locked-face-thumbnail.active {
            border-color: #48bb78;
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.5);
        }

        .zoom-indicator {
            position: absolute;
            bottom: 110px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .zoom-bar {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .zoom-level {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .zoom-fill {
            height: 100%;
            background: #fff;
            width: 30%;
            transition: width 0.5s ease;
        }

        .face-count {
            position: absolute;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        .tracking-mode {
            position: absolute;
            top: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Portrait to landscape adaptation */
        @media (orientation: landscape) {
            .center-guide {
                width: 120px;
                height: 120px;
            }
            
            .controls {
                bottom: 20px;
            }
            
            .zoom-indicator {
                bottom: 90px;
            }
            
            .locked-faces-container {
                top: 20px;
                right: 150px;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .control-btn {
                width: 65px;
                height: 65px;
                font-size: 1.5rem;
            }
            
            .status {
                padding: 10px 20px;
            }
            
            .zoom-bar {
                padding: 8px 16px;
            }
            
            .locked-faces-container {
                top: 120px;
                right: 10px;
                max-width: 100px;
            }
            
            .locked-face-thumbnail {
                width: 50px;
                height: 50px;
            }
        }

        /* Hide UI elements when in fullscreen and no interaction */
        .container.ui-hidden .status-bar,
        .container.ui-hidden .controls,
        .container.ui-hidden .pwa-install,
        .container.ui-hidden .zoom-indicator,
        .container.ui-hidden .face-count,
        .container.ui-hidden .recording-indicator,
        .container.ui-hidden .locked-faces-container,
        .container.ui-hidden .tracking-mode {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .container:not(.ui-hidden) .status-bar,
        .container:not(.ui-hidden) .controls,
        .container:not(.ui-hidden) .pwa-install,
        .container:not(.ui-hidden) .zoom-indicator,
        .container:not(.ui-hidden) .face-count,
        .container:not(.ui-hidden) .recording-indicator,
        .container:not(.ui-hidden) .locked-faces-container,
        .container:not(.ui-hidden) .tracking-mode {
            opacity: 1;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
        </div>
        <div id="overlay"></div>
        <div class="center-guide"></div>
        
        <div class="status-bar">
            <div class="status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
        
        <div class="recording-indicator" id="recording-indicator" style="display: none;">
            <div class="recording-dot"></div>
            <span id="recording-timer">Recording 00:00</span>
        </div>
        
        <div class="face-count">
            <span id="face-count">Faces: 0</span>
        </div>
        
        <div class="tracking-mode">
            <span id="tracking-mode">Auto Tracking</span>
        </div>
        
        <div class="locked-faces-container" id="locked-faces-container" style="display: none;">
            <!-- Locked face thumbnails will be added here -->
        </div>
        
        <div class="zoom-indicator">
            <div class="zoom-bar">
                <span>Zoom</span>
                <div class="zoom-level">
                    <div class="zoom-fill" id="zoom-fill"></div>
                </div>
                <span id="zoom-percent">100%</span>
            </div>
        </div>
        
        <div class="controls">
            <button class="control-btn" id="toggle-camera">
                <span>üîÑ</span>
            </button>
            <button class="control-btn" id="capture">
                <span>üì∏</span>
            </button>
            <button class="control-btn" id="record">
                <span>‚è∫Ô∏è</span>
            </button>
        </div>
        
        <div class="pwa-install" id="installButton" style="display: none;">
            <span>‚¨áÔ∏è</span> Install
        </div>
    </div>

    <script>
        // DOM elements
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const container = document.getElementById('container');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const faceCount = document.getElementById('face-count');
        const trackingMode = document.getElementById('tracking-mode');
        const zoomFill = document.getElementById('zoom-fill');
        const zoomPercent = document.getElementById('zoom-percent');
        const toggleCameraButton = document.getElementById('toggle-camera');
        const captureButton = document.getElementById('capture');
        const recordButton = document.getElementById('record');
        const recordingIndicator = document.getElementById('recording-indicator');
        const recordingTimer = document.getElementById('recording-timer');
        const lockedFacesContainer = document.getElementById('locked-faces-container');
        const installButton = document.getElementById('installButton');

        // App state
        let stream = null;
        let model = null;
        let isTracking = false;
        let animationId = null;
        let currentZoom = 1;
        let targetZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let targetPanX = 0;
        let targetPanY = 0;
        let faceDetected = false;
        let uiTimeout = null;
        let deferredPrompt = null;
        
        // Video recording state
        let mediaRecorder = null;
        let isRecording = false;
        let recordingStartTime = null;
        let recordingInterval = null;
        let fileHandle = null;
        let writableStream = null;

        // Face locking system
        let lockedFaces = new Map(); // Map of faceId -> { data, thumbnail, element, lastSeen }
        let nextFaceId = 1;
        const MAX_LOCKED_FACES = 10;

        // Performance optimization
        let detectionFrameSkip = 0;
        const DETECTION_INTERVAL = 2; // Reduced for smoother tracking

        // Initialize the app
        async function init() {
            try {
                statusText.textContent = 'Loading AI model...';
                
                // Load the BlazeFace model for face detection
                model = await blazeface.load();
                statusText.textContent = 'AI model loaded';
                
                // Start the camera
                await startCamera();
                
                // Start face detection
                startFaceDetection();
                
                // Set up PWA installation
                setupPWA();
                
                // Set up UI auto-hide
                setupUIHide();
                
            } catch (error) {
                console.error('Error initializing app:', error);
                statusText.textContent = 'Error initializing app';
            }
        }

        // Start camera
        async function startCamera() {
            try {
                statusText.textContent = 'Starting camera...';
                
                // Try to get user media with preferred constraints
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const videoConstraints = isMobile ? 
                    { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' } :
                    { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: 'user' };
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: videoConstraints,
                    audio: true  // Enable audio for video recording
                });
                
                video.srcObject = stream;
                video.muted = true; // Mute speakers by default
                statusText.textContent = 'Camera active - Tracking faces';
                statusDot.classList.add('active');
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                statusText.textContent = 'Camera access denied';
            }
        }

        // Start face detection loop
        function startFaceDetection() {
            if (!model) return;
            
            isTracking = true;
            detectFaces();
        }

        // Detect faces and adjust frame
        async function detectFaces() {
            if (!isTracking || !model) return;
            
            // Skip frames for performance
            detectionFrameSkip = (detectionFrameSkip + 1) % DETECTION_INTERVAL;
            if (detectionFrameSkip !== 0) {
                animationId = requestAnimationFrame(detectFaces);
                return;
            }
            
            try {
                // Perform face detection
                const predictions = await model.estimateFaces(video, false);
                
                // Update face count
                faceCount.textContent = `Faces: ${predictions.length}`;
                
                // Clear previous face indicators
                overlay.innerHTML = '';
                
                // Re-identify locked faces
                updateLockedFaces(predictions);
                
                if (predictions.length > 0) {
                    faceDetected = true;
                    
                    let allFaceBounds = {
                        minX: Infinity, maxX: -Infinity,
                        minY: Infinity, maxY: -Infinity
                    };
                    
                    predictions.forEach((prediction, index) => {
                        const [x, y, width, height] = [
                            prediction.topLeft[0],
                            prediction.topLeft[1],
                            prediction.bottomRight[0] - prediction.topLeft[0],
                            prediction.bottomRight[1] - prediction.topLeft[1]
                        ];
                        
                        const centerX = x + width / 2;
                        const centerY = y + height / 2;
                        
                        // Update bounds for all faces
                        allFaceBounds.minX = Math.min(allFaceBounds.minX, x);
                        allFaceBounds.maxX = Math.max(allFaceBounds.maxX, x + width);
                        allFaceBounds.minY = Math.min(allFaceBounds.minY, y);
                        allFaceBounds.maxY = Math.max(allFaceBounds.maxY, y + height);
                        
                        // Draw professional crosshair indicator
                        const crosshair = document.createElement('div');
                        crosshair.className = 'crosshair';
                        crosshair.style.left = `${centerX}px`;
                        crosshair.style.top = `${centerY}px`;
                        
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        crosshair.appendChild(dot);
                        
                        // Check if this face is locked
                        const isLocked = Array.from(lockedFaces.values()).some(face => 
                            face.data && Math.abs(face.data.centerX - centerX) < 50 && 
                            Math.abs(face.data.centerY - centerY) < 50
                        );
                        
                        if (isLocked) {
                            crosshair.classList.add('locked');
                        }
                        
                        // Add click event to lock/unlock face
                        crosshair.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleFaceLock(prediction);
                        });
                        
                        overlay.appendChild(crosshair);
                    });
                    
                    // Calculate framing based on locked faces or all faces
                    let targetBounds;
                    let trackingText = 'Auto Tracking';
                    
                    if (lockedFaces.size > 0) {
                        // Use locked faces for framing
                        targetBounds = calculateLockedFacesBounds();
                        trackingText = `Tracking ${lockedFaces.size} Locked Face${lockedFaces.size > 1 ? 's' : ''}`;
                    } else {
                        // Use all detected faces for framing
                        targetBounds = allFaceBounds;
                        trackingText = 'Auto Tracking';
                    }
                    
                    trackingMode.textContent = trackingText;
                    
                    // Calculate how far the center is from the video center
                    const boundsCenterX = (targetBounds.minX + targetBounds.maxX) / 2;
                    const boundsCenterY = (targetBounds.minY + targetBounds.maxY) / 2;
                    
                    const videoCenterX = video.videoWidth / 2;
                    const videoCenterY = video.videoHeight / 2;
                    
                    const offsetX = boundsCenterX - videoCenterX;
                    const offsetY = boundsCenterY - videoCenterY;
                    
                    // Calculate target pan (normalized values between -1 and 1)
                    targetPanX = -offsetX / videoCenterX;
                    targetPanY = -offsetY / videoCenterY;
                    
                    // Calculate target zoom based on bounds size
                    const boundsWidth = targetBounds.maxX - targetBounds.minX;
                    const boundsHeight = targetBounds.maxY - targetBounds.minY;
                    
                    const zoomX = video.videoWidth / boundsWidth;
                    const zoomY = video.videoHeight / boundsHeight;
                    
                    // Choose the smaller zoom level to fit the whole frame
                    targetZoom = Math.min(zoomX, zoomY) * 0.6; // 60% of the screen
                    targetZoom = Math.max(1, Math.min(targetZoom, 3)); // Clamp zoom
                    
                } else {
                    faceDetected = false;
                    // No faces detected - reset to default view
                    targetPanX = 0;
                    targetPanY = 0;
                    targetZoom = 1;
                    trackingMode.textContent = 'Auto Tracking';
                }
                
                // Apply smooth transitions to current values
                applySmoothTransitions();
                
            } catch (error) {
                console.error('Error detecting faces:', error);
            }
            
            // Continue detection loop
            animationId = requestAnimationFrame(detectFaces);
        }

        // Re-identify locked faces in the new set of predictions
        function updateLockedFaces(predictions) {
            if (lockedFaces.size === 0) return;

            const matchedPredictionIndices = new Set();

            lockedFaces.forEach((face, faceId) => {
                let bestMatch = null;
                let minDistance = Infinity;

                predictions.forEach((prediction, index) => {
                    if (matchedPredictionIndices.has(index)) return;

                    const [x, y] = prediction.topLeft;
                    const centerX = x + (prediction.bottomRight[0] - x) / 2;
                    const centerY = y + (prediction.bottomRight[1] - y) / 2;

                    const distance = Math.sqrt(
                        Math.pow(centerX - face.data.centerX, 2) +
                        Math.pow(centerY - face.data.centerY, 2)
                    );

                    if (distance < minDistance && distance < 100) { // 100px threshold
                        minDistance = distance;
                        bestMatch = { prediction, index };
                    }
                });

                if (bestMatch) {
                    const [x, y, width, height] = [
                        bestMatch.prediction.topLeft[0],
                        bestMatch.prediction.topLeft[1],
                        bestMatch.prediction.bottomRight[0] - bestMatch.prediction.topLeft[0],
                        bestMatch.prediction.bottomRight[1] - bestMatch.prediction.topLeft[1]
                    ];
                    face.data = {
                        centerX: x + width / 2,
                        centerY: y + height / 2,
                        width,
                        height
                    };
                    face.lastSeen = Date.now();
                    matchedPredictionIndices.add(bestMatch.index);
                } else {
                    // If face not seen for a while, unlock it
                    if (Date.now() - face.lastSeen > 3000) { // 3 seconds
                        unlockedFace(faceId);
                    }
                }
            });
        }

        // Calculate bounds for all locked faces to include full figure
        function calculateLockedFacesBounds() {
            const bounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity
            };
            
            lockedFaces.forEach(face => {
                // Estimate full body bounds (face is about 1/7th of body height)
                const bodyHeight = face.data.height * 7;
                const bodyWidth = bodyHeight / 2; // Aspect ratio of a person
                
                const bodyX = face.data.centerX - bodyWidth / 2;
                const bodyY = face.data.centerY - face.data.height * 1.5; // Position face in upper part
                
                bounds.minX = Math.min(bounds.minX, bodyX);
                bounds.maxX = Math.max(bounds.maxX, bodyX + bodyWidth);
                bounds.minY = Math.min(bounds.minY, bodyY);
                bounds.maxY = Math.max(bounds.maxY, bodyY + bodyHeight);
            });
            
            return bounds;
        }

        // Toggle face lock
        function toggleFaceLock(prediction) {
            const [x, y, width, height] = [
                prediction.topLeft[0],
                prediction.topLeft[1],
                prediction.bottomRight[0] - prediction.topLeft[0],
                prediction.bottomRight[1] - prediction.topLeft[1]
            ];
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            const existingFaceId = Array.from(lockedFaces.entries()).find(([id, face]) => 
                face.data && Math.abs(face.data.centerX - centerX) < 50 && 
                Math.abs(face.data.centerY - centerY) < 50
            )?.[0];
            
            if (existingFaceId) {
                unlockedFace(existingFaceId);
            } else {
                if (lockedFaces.size < MAX_LOCKED_FACES) {
                    lockFace(prediction);
                } else {
                    statusText.textContent = `Maximum ${MAX_LOCKED_FACES} faces can be locked`;
                    setTimeout(() => {
                        if (stream) statusText.textContent = 'Camera active - Tracking faces';
                    }, 2000);
                }
            }
        }

        // Lock a face
        function lockFace(prediction) {
            const faceId = nextFaceId++;
            
            const [x, y, width, height] = [
                prediction.topLeft[0],
                prediction.topLeft[1],
                prediction.bottomRight[0] - prediction.topLeft[0],
                prediction.bottomRight[1] - prediction.topLeft[1]
            ];
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            // Create thumbnail
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const context = canvas.getContext('2d');
            context.drawImage(video, x, y, width, height, 0, 0, 100, 100);
            const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
            
            // Create thumbnail element
            const thumbnail = document.createElement('img');
            thumbnail.className = 'locked-face-thumbnail';
            thumbnail.src = thumbnailUrl;
            thumbnail.title = 'Click to unlock';
            
            thumbnail.addEventListener('click', () => {
                unlockedFace(faceId);
            });
            
            // Store face data
            lockedFaces.set(faceId, {
                data: { centerX, centerY, width, height },
                thumbnail: thumbnailUrl,
                element: thumbnail,
                lastSeen: Date.now()
            });
            
            // Update UI
            lockedFacesContainer.appendChild(thumbnail);
            lockedFacesContainer.style.display = 'flex';
            
            statusText.textContent = 'Face locked - Tracking subject';
            setTimeout(() => {
                if (stream) statusText.textContent = 'Camera active - Tracking faces';
            }, 2000);
        }

        // Unlock a face
        function unlockedFace(faceId) {
            const face = lockedFaces.get(faceId);
            if (face) {
                face.element.remove();
                lockedFaces.delete(faceId);
                
                if (lockedFaces.size === 0) {
                    lockedFacesContainer.style.display = 'none';
                }
                
                statusText.textContent = 'Face unlocked';
                setTimeout(() => {
                    if (stream) statusText.textContent = 'Camera active - Tracking faces';
                }, 2000);
            }
        }

        // Apply smooth transitions to zoom and pan
        function applySmoothTransitions() {
            // Smoother transitions
            const zoomDiff = targetZoom - currentZoom;
            currentZoom += zoomDiff * 0.03;
            
            const panXDiff = targetPanX - currentPanX;
            const panYDiff = targetPanY - currentPanY;
            currentPanX += panXDiff * 0.04;
            currentPanY += panYDiff * 0.04;
            
            // Apply transformations to video
            const scale = currentZoom;
            const translateX = currentPanX * (100 / scale);
            const translateY = currentPanY * (100 / scale);
            
            video.style.transform = `scale(${scale}) translate(${translateX}%, ${translateY}%)`;
            
            // Update zoom indicator
            const zoomPercentage = Math.round(currentZoom * 100);
            zoomFill.style.width = `${Math.min(100, (currentZoom - 1) / 2 * 100)}%`; // Max zoom is 3
            zoomPercent.textContent = `${zoomPercentage}%`;
        }

        // Capture photo
        captureButton.addEventListener('click', () => {
            if (!stream) return;
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.scale(currentZoom, currentZoom);
            const translateX = currentPanX * (canvas.width / currentZoom / 2);
            const translateY = currentPanY * (canvas.height / currentZoom / 2);
            context.translate(translateX, translateY);
            context.drawImage(video, -canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
            context.restore();
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `centre-stage-photo-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png', 0.95);
            link.click();
            
            statusText.textContent = 'Photo saved to Downloads';
            setTimeout(() => {
                if (stream) statusText.textContent = 'Camera active - Tracking faces';
            }, 2000);
        });

        // Toggle recording
        recordButton.addEventListener('click', async () => {
            if (!stream) return;
            
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        });

        // Start video recording
        async function startRecording() {
            try {
                // Mute audio output during setup
                video.muted = true;

                // 1. Check for File System Access API
                if (!('showSaveFilePicker' in window)) {
                    throw new Error('File System Access API not supported. Please use Chrome or Edge.');
                }

                // 2. Prompt user for save location
                statusText.textContent = 'Select save location...';
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `centre-stage-video-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`,
                        types: [{
                            description: 'WebM Video',
                            accept: { 'video/webm': ['.webm'] }
                        }]
                    });
                } catch (err) {
                    // Handle user cancelling the file picker
                    if (err.name !== 'AbortError') console.error('File picker error:', err);
                    statusText.textContent = 'Camera active - Tracking faces';
                    video.muted = false; // Unmute if cancelled
                    return;
                }

                // 3. Attempt to switch to the back camera
                statusText.textContent = 'Checking for back camera...';
                try {
                    const videoConstraints = {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: 'environment' // Prefer back camera
                    };

                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: videoConstraints,
                        audio: true
                    });

                    // If successful, stop the old stream and use the new one
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                    stream = newStream;
                    video.srcObject = stream;
                    console.log('Successfully switched to back camera.');
                    statusText.textContent = 'Using back camera';
                    // Wait for metadata to ensure video dimensions are correct before recording
                    await new Promise(resolve => video.onloadedmetadata = resolve);

                } catch (error) {
                    console.warn('Could not switch to back camera, continuing with current camera.', error.name);
                    statusText.textContent = 'Back camera not found, using front';
                    // Add a small delay so the user can see the message
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }

                // 4. Prepare for recording
                writableStream = await fileHandle.createWritable();

                const options = {
                    mimeType: 'video/webm; codecs=vp9,opus',
                    videoBitsPerSecond: 5000000 // Increased bitrate for better quality
                };

                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }

                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data && event.data.size > 0 && writableStream) {
                        try {
                            await writableStream.write(event.data);
                        } catch (error) {
                            console.error('Error writing to file:', error);
                            statusText.textContent = 'Error writing video file';
                            stopRecording();
                        }
                    }
                };

                mediaRecorder.onstop = async () => {
                    if (writableStream) {
                        try {
                            await writableStream.close();
                            writableStream = null;
                            fileHandle = null;

                            statusText.textContent = 'Video saved successfully';
                            setTimeout(() => {
                                if (stream) statusText.textContent = 'Camera active - Tracking faces';
                            }, 3000);
                        } catch (error) {
                            console.error('Error closing file:', error);
                            statusText.textContent = 'Error saving video file';
                        }
                    }
                    video.muted = false;
                };

                // 5. Start recording
                mediaRecorder.start(1000); // Collect data in 1-second chunks
                isRecording = true;
                recordingStartTime = Date.now();

                // Update UI to reflect recording state
                recordButton.classList.add('recording');
                recordButton.innerHTML = '<span>‚èπÔ∏è</span>';
                recordingIndicator.style.display = 'flex';

                updateRecordingTimer();

                statusText.textContent = 'Recording...';

            } catch (error) {
                console.error('Error starting recording:', error);
                statusText.textContent = error.message.includes('File System Access API') ?
                    'Recording requires Chrome/Edge browser' : 'Error starting recording';
                video.muted = false;
                // Clean up resources on failure
                if (writableStream) {
                    try { await writableStream.close(); } catch (e) { }
                    writableStream = null;
                    fileHandle = null;
                }
            }
        }

        // Stop video recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                recordButton.classList.remove('recording');
                recordButton.innerHTML = '<span>‚è∫Ô∏è</span>';
                recordingIndicator.style.display = 'none';
                
                clearInterval(recordingInterval);
                video.muted = false;
            }
        }

        // Update recording timer
        function updateRecordingTimer() {
            if (!isRecording) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            recordingTimer.textContent = `Recording ${minutes}:${seconds}`;
            
            recordingInterval = setTimeout(updateRecordingTimer, 1000);
        }

        // Toggle camera (front/back if available)
        toggleCameraButton.addEventListener('click', async () => {
            if (!stream) return;
            
            stream.getTracks().forEach(track => track.stop());
            
            try {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const videoConstraints = isMobile ? 
                    { width: { ideal: 1280 }, height: { ideal: 720 } } :
                    { width: { ideal: 1920 }, height: { ideal: 1080 } };
                
                const currentFacingMode = video.srcObject.getVideoTracks()[0].getSettings().facingMode;
                videoConstraints.facingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints,
                    audio: true
                });
                
                video.srcObject = stream;
                video.muted = true;
                
                if (isRecording) {
                    stopRecording();
                    setTimeout(startRecording, 500);
                }
                
            } catch (error) {
                console.error('Error switching camera:', error);
                await startCamera();
            }
        });

        // Set up UI auto-hide
        function setupUIHide() {
            container.addEventListener('mousemove', showUI);
            container.addEventListener('touchstart', showUI);
            hideUIAfterTimeout();
        }

        function showUI() {
            container.classList.remove('ui-hidden');
            clearTimeout(uiTimeout);
            hideUIAfterTimeout();
        }

        function hideUIAfterTimeout() {
            uiTimeout = setTimeout(() => {
                container.classList.add('ui-hidden');
            }, 3000);
        }

        // PWA Installation
        function setupPWA() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installButton.style.display = 'flex';
            });

            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    installButton.style.display = 'none';
                }
                
                deferredPrompt = null;
            });

            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('App launched in standalone mode');
            }
        }

        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Initialize the app when the page loads
        window.addEventListener('load', init);

        // Clean up when the page is closed
        window.addEventListener('beforeunload', () => {
            isTracking = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (isRecording) {
                stopRecording();
            }
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
        });
    </script>
</body>
</html>
