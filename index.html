<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Professional Centre Stage Camera with AI face tracking">
    <title>Centre Stage Camera</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Outer Frame - Fixed to device dimensions */
        .outer-frame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            z-index: 1;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .crosshair {
            position: absolute;
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            opacity: 0.9;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            transform: translateX(-50%);
        }

        .crosshair .dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }

        .crosshair.locked {
            z-index: 10;
        }

        .crosshair.locked::before, 
        .crosshair.locked::after {
            background: #48bb78;
            height: 3px;
            width: 3px;
        }

        .crosshair.locked .dot {
            background: #48bb78;
            width: 10px;
            height: 10px;
        }

        .center-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 3;
            pointer-events: none;
            opacity: 0.7;
        }

        .center-guide::before, .center-guide::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }

        .center-guide::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .center-guide::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }

        /* Controls positioned 30px up from bottom */
        .controls {
            position: absolute;
            bottom: 60px; /* 30px up from previous 30px position */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 25px;
            z-index: 10;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.7rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            outline: none;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn.recording {
            background: rgba(220, 53, 69, 0.3);
            animation: pulse-red 2s infinite;
        }

        .status-bar {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .status {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e53e3e;
        }

        .status-dot.active {
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .pwa-install {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 18px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .pwa-install:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(220, 53, 69, 0.8);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            font-weight: 500;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: pulse 1.5s infinite;
        }

        /* Countdown overlay */
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            font-size: 8rem;
            font-weight: bold;
            color: white;
            display: none;
        }

        /* Processing overlay */
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            font-size: 1.5rem;
            color: white;
            flex-direction: column;
            gap: 20px;
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #48bb78;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Thumbnails container with flex */
        .locked-faces-container {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 10px;
            border-radius: 15px;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 150px;
            justify-content: flex-end;
        }

        .locked-face-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .locked-face-thumbnail:hover {
            border-color: #48bb78;
            transform: scale(1.05);
        }

        .locked-face-thumbnail.active {
            border-color: #48bb78;
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.5);
        }

        .zoom-indicator {
            position: absolute;
            bottom: 140px; /* Adjusted for moved controls */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }

        .zoom-bar {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .zoom-level {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .zoom-fill {
            height: 100%;
            background: #fff;
            width: 30%;
            transition: width 0.3s ease;
        }

        .face-count {
            position: absolute;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        .tracking-mode {
            position: absolute;
            top: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        .camera-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            z-index: 10;
            font-weight: 500;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        /* Force landscape for back camera */
        .landscape-mode {
            transform: rotate(0deg) !important;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
            
            .status {
                padding: 10px 20px;
                font-size: 0.8rem;
            }
            
            .zoom-bar {
                padding: 8px 16px;
                font-size: 0.8rem;
            }
            
            .locked-faces-container {
                top: 120px;
                right: 10px;
                max-width: 130px;
            }
            
            .locked-face-thumbnail {
                width: 50px;
                height: 50px;
            }
            
            .face-count, .tracking-mode, .camera-indicator {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .countdown-overlay {
                font-size: 6rem;
            }
        }

        /* Hide UI elements when in fullscreen and no interaction */
        .outer-frame.ui-hidden .status-bar,
        .outer-frame.ui-hidden .controls,
        .outer-frame.ui-hidden .pwa-install,
        .outer-frame.ui-hidden .zoom-indicator,
        .outer-frame.ui-hidden .face-count,
        .outer-frame.ui-hidden .recording-indicator,
        .outer-frame.ui-hidden .locked-faces-container,
        .outer-frame.ui-hidden .tracking-mode,
        .outer-frame.ui-hidden .camera-indicator {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .outer-frame:not(.ui-hidden) .status-bar,
        .outer-frame:not(.ui-hidden) .controls,
        .outer-frame:not(.ui-hidden) .pwa-install,
        .outer-frame:not(.ui-hidden) .zoom-indicator,
        .outer-frame:not(.ui-hidden) .face-count,
        .outer-frame:not(.ui-hidden) .recording-indicator,
        .outer-frame:not(.ui-hidden) .locked-faces-container,
        .outer-frame:not(.ui-hidden) .tracking-mode,
        .outer-frame:not(.ui-hidden) .camera-indicator {
            opacity: 1;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>
    <!-- Outer Frame - Fixed to device dimensions -->
    <div class="outer-frame" id="outer-frame">
        <video id="video" autoplay playsinline muted></video>
        <div id="overlay"></div>
        <div class="center-guide"></div>
        
        <!-- Countdown Overlay -->
        <div class="countdown-overlay" id="countdown-overlay"></div>
        
        <!-- Processing Overlay -->
        <div class="processing-overlay" id="processing-overlay">
            <div class="spinner"></div>
            <div>Processing Video - Trimming last 10 seconds...</div>
        </div>
        
        <div class="status-bar">
            <div class="status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
        
        <div class="recording-indicator" id="recording-indicator" style="display: none;">
            <div class="recording-dot"></div>
            <span id="recording-timer">Recording 00:00</span>
        </div>
        
        <div class="camera-indicator">
            <span id="camera-mode">Rear Camera</span>
        </div>
        
        <div class="face-count">
            <span id="face-count">Faces: 0</span>
        </div>
        
        <div class="tracking-mode">
            <span id="tracking-mode">Auto Tracking</span>
        </div>
        
        <div class="locked-faces-container" id="locked-faces-container" style="display: none;">
            <!-- Locked face thumbnails will be added here -->
        </div>
        
        <div class="zoom-indicator">
            <div class="zoom-bar">
                <span>Zoom</span>
                <div class="zoom-level">
                    <div class="zoom-fill" id="zoom-fill"></div>
                </div>
                <span id="zoom-percent">100%</span>
            </div>
        </div>
        
        <!-- Controls moved 30px up -->
        <div class="controls">
            <button class="control-btn" id="toggle-camera">
                <span>üîÑ</span>
            </button>
            <button class="control-btn" id="capture">
                <span>üì∏</span>
            </button>
            <button class="control-btn" id="record">
                <span>‚è∫Ô∏è</span>
            </button>
        </div>
        
        <div class="pwa-install" id="installButton" style="display: none;">
            <span>‚¨áÔ∏è</span> Install
        </div>
        
        <!-- Hidden canvas for recording -->
        <canvas id="recording-canvas" style="display: none;"></canvas>
    </div>

    <script>
        // DOM elements
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const outerFrame = document.getElementById('outer-frame');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const faceCount = document.getElementById('face-count');
        const trackingMode = document.getElementById('tracking-mode');
        const cameraMode = document.getElementById('camera-mode');
        const zoomFill = document.getElementById('zoom-fill');
        const zoomPercent = document.getElementById('zoom-percent');
        const toggleCameraButton = document.getElementById('toggle-camera');
        const captureButton = document.getElementById('capture');
        const recordButton = document.getElementById('record');
        const recordingIndicator = document.getElementById('recording-indicator');
        const recordingTimer = document.getElementById('recording-timer');
        const lockedFacesContainer = document.getElementById('locked-faces-container');
        const installButton = document.getElementById('installButton');
        const recordingCanvas = document.getElementById('recording-canvas');
        const recordingCtx = recordingCanvas.getContext('2d');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const processingOverlay = document.getElementById('processing-overlay');

        // App state
        let stream = null;
        let model = null;
        let isTracking = false;
        let animationId = null;
        let currentZoom = 1;
        let targetZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let targetPanX = 0;
        let targetPanY = 0;
        let faceDetected = false;
        let uiTimeout = null;
        let deferredPrompt = null;
        
        // Video recording state
        let mediaRecorder = null;
        let isRecording = false;
        let recordingStartTime = null;
        let recordingInterval = null;
        let fileHandle = null;
        let writableStream = null;
        let isFrontCamera = false;
        let recordedChunks = [];
        let recordingDuration = 0;

        // Face locking system
        let lockedFaces = new Map();
        let nextFaceId = 1;
        const MAX_LOCKED_FACES = 10;

        // Performance optimization
        let detectionFrameSkip = 0;
        const DETECTION_INTERVAL = 3;

        // Audio context for beep sounds
        let audioContext = null;

        // Initialize the app
        async function init() {
            try {
                statusText.textContent = 'Loading AI model...';
                
                // Load the BlazeFace model for face detection
                model = await blazeface.load();
                statusText.textContent = 'AI model loaded';
                
                // Start the camera (start with rear camera)
                await startCamera(false);
                
                // Start face detection
                startFaceDetection();
                
                // Set up PWA installation
                setupPWA();
                
                // Set up UI auto-hide
                setupUIHide();
                
                // Initialize audio context for beep sounds
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
            } catch (error) {
                console.error('Error initializing app:', error);
                statusText.textContent = 'Error initializing app';
            }
        }

        // Play beep sound
        function playBeep(frequency = 800, duration = 200) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        // Start camera with specified facing mode
        async function startCamera(useFrontCamera = false) {
            try {
                statusText.textContent = 'Starting camera...';
                
                // Stop existing stream if any
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                // Set up audio constraints with noise suppression
                const audioConstraints = {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 16000,
                    channelCount: 1
                };
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Use maximum quality settings
                const videoConstraints = {
                    width: { ideal: 4096 },
                    height: { ideal: 2160 },
                    frameRate: { ideal: 60 },
                    facingMode: useFrontCamera ? 'user' : 'environment'
                };
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: videoConstraints,
                    audio: audioConstraints
                });
                
                video.srcObject = stream;
                video.muted = true;
                isFrontCamera = useFrontCamera;
                
                // Apply orientation settings
                if (!useFrontCamera) {
                    // Force landscape for back camera
                    outerFrame.classList.add('landscape-mode');
                    try {
                        await screen.orientation.lock('landscape');
                    } catch (e) {
                        console.log('Orientation lock not supported:', e);
                    }
                } else {
                    // Portrait for front camera
                    outerFrame.classList.remove('landscape-mode');
                    try {
                        await screen.orientation.lock('portrait');
                    } catch (e) {
                        console.log('Orientation lock not supported:', e);
                    }
                }
                
                // Update UI based on camera mode
                cameraMode.textContent = useFrontCamera ? 'Front Camera' : 'Rear Camera';
                
                // Disable recording for front camera
                recordButton.disabled = useFrontCamera;
                if (useFrontCamera) {
                    recordButton.title = 'Recording disabled for front camera';
                    // Reset zoom and pan for front camera
                    currentZoom = 1;
                    targetZoom = 1;
                    currentPanX = 0;
                    targetPanX = 0;
                    currentPanY = 0;
                    targetPanY = 0;
                    video.style.transform = 'scale(1) translate(0%, 0%)';
                } else {
                    recordButton.title = 'Start recording';
                }
                
                statusText.textContent = `Camera active - ${useFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                statusDot.classList.add('active');
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                statusText.textContent = 'Camera access denied';
            }
        }

        // Toggle between front and rear cameras
        async function toggleCamera() {
            if (!stream) return;
            
            // Stop current recording if active
            if (isRecording) {
                stopRecording();
            }
            
            // Switch to opposite camera
            await startCamera(!isFrontCamera);
        }

        // Start face detection loop
        function startFaceDetection() {
            if (!model) return;
            
            isTracking = true;
            detectFaces();
        }

        // Intelligent framing algorithm
        function calculateOptimalFraming(faces) {
            if (faces.length === 0) return { zoom: 1, panX: 0, panY: 0 };
            
            // Calculate bounding box of all faces
            let bounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity
            };
            
            faces.forEach(face => {
                // Estimate full body area (face is about 1/7th of body height)
                const bodyHeight = face.height * 4;
                const bodyWidth = face.width * 2;
                const bodyX = face.x - bodyWidth / 2;
                const bodyY = face.y - bodyHeight / 4;
                const bodyMaxX = bodyX + bodyWidth;
                const bodyMaxY = bodyY + bodyHeight;
                
                bounds.minX = Math.min(bounds.minX, bodyX);
                bounds.maxX = Math.max(bounds.maxX, bodyMaxX);
                bounds.minY = Math.min(bounds.minY, bodyY);
                bounds.maxY = Math.max(bounds.maxY, bodyMaxY);
            });
            
            // Calculate center of the group
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            // Calculate required zoom to fit all bodies
            const boundsWidth = bounds.maxX - bounds.minX;
            const boundsHeight = bounds.maxY - bounds.minY;
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            // Calculate zoom needed to fit the group
            const zoomX = videoWidth / (boundsWidth * 1.2); // 20% padding
            const zoomY = videoHeight / (boundsHeight * 1.2);
            let zoom = Math.min(zoomX, zoomY, 2); // Max 2x zoom
            
            // Don't zoom in too much - prioritize showing full figures
            if (faces.length > 1) {
                zoom = Math.min(zoom, 1.5); // More conservative zoom for multiple people
            }
            
            zoom = Math.max(0.7, Math.min(2, zoom)); // Clamp between 0.7x and 2x
            
            // Calculate pan to center the group
            const videoCenterX = videoWidth / 2;
            const videoCenterY = videoHeight / 2;
            const offsetX = centerX - videoCenterX;
            const offsetY = centerY - videoCenterY;
            const panX = -offsetX / videoCenterX;
            const panY = -offsetY / videoCenterY;
            
            return {
                zoom: zoom,
                panX: Math.max(-1, Math.min(1, panX)),
                panY: Math.max(-1, Math.min(1, panY))
            };
        }

        // Detect faces and adjust frame
        async function detectFaces() {
            if (!isTracking || !model) return;
            
            detectionFrameSkip = (detectionFrameSkip + 1) % DETECTION_INTERVAL;
            if (detectionFrameSkip !== 0) {
                animationId = requestAnimationFrame(detectFaces);
                return;
            }
            
            try {
                const predictions = await model.estimateFaces(video, false);
                
                faceCount.textContent = `Faces: ${predictions.length}`;
                overlay.innerHTML = '';
                
                if (predictions.length > 0) {
                    faceDetected = true;
                    
                    let faces = [];
                    
                    predictions.forEach((prediction, index) => {
                        const [x, y, width, height] = [
                            prediction.topLeft[0],
                            prediction.topLeft[1],
                            prediction.bottomRight[0] - prediction.topLeft[0],
                            prediction.bottomRight[1] - prediction.topLeft[1]
                        ];
                        
                        // Calculate center of face (nose bridge area)
                        const centerX = x + width / 2;
                        const centerY = y + height / 3; // Higher up for nose bridge
                        
                        faces.push({ x: centerX, y: centerY, width, height, index });
                        
                        // Draw crosshair at face center
                        const crosshair = document.createElement('div');
                        crosshair.className = 'crosshair';
                        crosshair.style.left = `${centerX}px`;
                        crosshair.style.top = `${centerY}px`;
                        
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        crosshair.appendChild(dot);
                        
                        const isLocked = Array.from(lockedFaces.values()).some(face => 
                            Math.abs(face.data.centerX - centerX) < 50 && 
                            Math.abs(face.data.centerY - centerY) < 50
                        );
                        
                        if (isLocked) {
                            crosshair.classList.add('locked');
                        }
                        
                        crosshair.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleFaceLock(centerX, centerY, width, height, index);
                        });
                        
                        overlay.appendChild(crosshair);
                    });
                    
                    // Apply intelligent framing (only for back camera)
                    if (!isFrontCamera) {
                        const framing = calculateOptimalFraming(faces);
                        targetZoom = framing.zoom;
                        targetPanX = framing.panX;
                        targetPanY = framing.panY;
                        
                        let trackingText = 'Auto Tracking';
                        if (lockedFaces.size > 0) {
                            trackingText = `Tracking ${lockedFaces.size} Locked Face${lockedFaces.size > 1 ? 's' : ''}`;
                        }
                        trackingMode.textContent = trackingText;
                    } else {
                        // Front camera: no zoom or pan
                        targetZoom = 1;
                        targetPanX = 0;
                        targetPanY = 0;
                        trackingMode.textContent = 'Face Marking Mode';
                    }
                    
                } else {
                    faceDetected = false;
                    // No faces detected - reset to default view
                    targetZoom = 1;
                    targetPanX = 0;
                    targetPanY = 0;
                    trackingMode.textContent = 'Auto Tracking';
                }
                
                applySmoothTransitions();
                
            } catch (error) {
                console.error('Error detecting faces:', error);
            }
            
            animationId = requestAnimationFrame(detectFaces);
        }

        // Apply faster transitions
        function applySmoothTransitions() {
            // Faster zoom transition
            const zoomDiff = targetZoom - currentZoom;
            currentZoom += zoomDiff * 0.2; // Faster transition
            
            // Faster pan transition
            const panXDiff = targetPanX - currentPanX;
            const panYDiff = targetPanY - currentPanY;
            currentPanX += panXDiff * 0.2; // Faster transition
            currentPanY += panYDiff * 0.2;
            
            // Apply transformations to video (only for back camera)
            if (!isFrontCamera) {
                const scale = currentZoom;
                const translateX = currentPanX * 50;
                const translateY = currentPanY * 50;
                video.style.transform = `scale(${scale}) translate(${translateX}%, ${translateY}%)`;
            }
            
            // Update zoom indicator
            const zoomPercentage = Math.round(currentZoom * 100);
            zoomFill.style.width = `${Math.min(100, (currentZoom - 1) * 100)}%`;
            zoomPercent.textContent = `${zoomPercentage}%`;
        }

        // Toggle face lock
        function toggleFaceLock(centerX, centerY, width, height, index) {
            const existingFaceId = Array.from(lockedFaces.entries()).find(([id, face]) => 
                Math.abs(face.data.centerX - centerX) < 50 && 
                Math.abs(face.data.centerY - centerY) < 50
            )?.[0];
            
            if (existingFaceId) {
                unlockedFace(existingFaceId);
            } else {
                if (lockedFaces.size < MAX_LOCKED_FACES) {
                    lockFace(centerX, centerY, width, height, index);
                } else {
                    statusText.textContent = `Maximum ${MAX_LOCKED_FACES} faces can be locked`;
                    setTimeout(() => {
                        if (stream) statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                    }, 2000);
                }
            }
        }

        // Lock a face
        function lockFace(centerX, centerY, width, height, index) {
            const faceId = nextFaceId++;
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 100;
            canvas.height = 100;
            
            // Capture face thumbnail
            context.drawImage(
                video,
                centerX - width / 2, centerY - height / 2, width, height,
                0, 0, 100, 100
            );
            
            const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.8);
            
            const thumbnail = document.createElement('img');
            thumbnail.className = 'locked-face-thumbnail';
            thumbnail.src = thumbnailUrl;
            thumbnail.title = 'Click to unlock';
            
            thumbnail.addEventListener('click', () => {
                unlockedFace(faceId);
            });
            
            lockedFaces.set(faceId, {
                data: { centerX, centerY, width, height, index },
                thumbnail: thumbnailUrl,
                element: thumbnail
            });
            
            lockedFacesContainer.appendChild(thumbnail);
            lockedFacesContainer.style.display = 'flex';
            
            statusText.textContent = 'Face locked - Tracking subject';
            setTimeout(() => {
                if (stream) statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
            }, 2000);
        }

        // Unlock a face
        function unlockedFace(faceId) {
            const face = lockedFaces.get(faceId);
            if (face) {
                face.element.remove();
                lockedFaces.delete(faceId);
                
                if (lockedFaces.size === 0) {
                    lockedFacesContainer.style.display = 'none';
                }
                
                statusText.textContent = 'Face unlocked';
                setTimeout(() => {
                    if (stream) statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                }, 2000);
            }
        }

        // Capture photo
        captureButton.addEventListener('click', () => {
            if (!stream) return;
            
            // Set canvas to outer frame dimensions
            recordingCanvas.width = outerFrame.clientWidth;
            recordingCanvas.height = outerFrame.clientHeight;
            
            // Draw exactly what's shown in viewfinder
            recordingCtx.save();
            recordingCtx.translate(recordingCanvas.width / 2, recordingCanvas.height / 2);
            recordingCtx.scale(currentZoom, currentZoom);
            recordingCtx.translate(currentPanX * 50, currentPanY * 50);
            recordingCtx.drawImage(
                video, 
                -recordingCanvas.width / 2, 
                -recordingCanvas.height / 2, 
                recordingCanvas.width, 
                recordingCanvas.height
            );
            recordingCtx.restore();
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `centre-stage-photo-${timestamp}.png`;
            link.href = recordingCanvas.toDataURL('image/png', 0.95);
            link.click();
            
            statusText.textContent = 'Photo saved to Downloads';
            setTimeout(() => {
                if (stream) statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
            }, 2000);
        });

        // 7-second countdown before recording
        async function startCountdown() {
            return new Promise((resolve) => {
                let count = 7;
                countdownOverlay.style.display = 'flex';
                countdownOverlay.textContent = count;
                
                playBeep(600, 500); // Initial beep
                
                const countdownInterval = setInterval(() => {
                    count--;
                    countdownOverlay.textContent = count;
                    playBeep(600, 500);
                    
                    if (count <= 0) {
                        clearInterval(countdownInterval);
                        countdownOverlay.style.display = 'none';
                        resolve();
                    }
                }, 1000);
            });
        }

        // Toggle recording - disabled for front camera
        recordButton.addEventListener('click', async () => {
            if (!stream || isFrontCamera) return;
            
            if (!isRecording) {
                // Start countdown then recording
                await startCountdown();
                await startRecording();
            } else {
                stopRecording();
            }
        });

        // Trim last 10 seconds from video
        async function trimVideo(blob) {
            return new Promise((resolve) => {
                // Create a video element to get duration
                const tempVideo = document.createElement('video');
                tempVideo.src = URL.createObjectURL(blob);
                
                tempVideo.onloadedmetadata = () => {
                    const duration = tempVideo.duration;
                    const trimmedDuration = Math.max(0, duration - 10); // Remove last 10 seconds
                    
                    // In a real implementation, you would use a video processing library
                    // For now, we'll simulate the processing and return the original
                    console.log(`Would trim video from ${duration}s to ${trimmedDuration}s`);
                    
                    // Simulate processing delay
                    setTimeout(() => {
                        URL.revokeObjectURL(tempVideo.src);
                        resolve(blob); // Return original for now
                    }, 2000);
                };
            });
        }

        // Start video recording
        async function startRecording() {
            if (isFrontCamera) {
                statusText.textContent = 'Recording disabled for front camera';
                return;
            }
            
            try {
                video.muted = true;
                
                if (!('showSaveFilePicker' in window)) {
                    throw new Error('File System Access API not supported. Please use Chrome or Edge.');
                }
                
                statusText.textContent = 'Select save location...';
                
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `centre-stage-video-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`,
                        types: [{
                            description: 'WebM Video',
                            accept: {'video/webm': ['.webm']}
                        }]
                    });
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('File picker error:', err);
                    }
                    statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                    video.muted = false;
                    return;
                }
                
                writableStream = await fileHandle.createWritable();
                recordedChunks = [];
                recordingDuration = 0;
                
                // Set up canvas for recording
                recordingCanvas.width = outerFrame.clientWidth;
                recordingCanvas.height = outerFrame.clientHeight;
                
                // Create canvas stream
                const canvasStream = recordingCanvas.captureStream(30);
                
                // Get audio track
                const audioTracks = stream.getAudioTracks();
                
                // Combine streams
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioTracks
                ]);
                
                // High quality recording settings
                const options = { 
                    mimeType: 'video/webm; codecs=vp9,opus',
                    videoBitsPerSecond: 100000000 // 100 Mbps
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8,opus';
                    options.videoBitsPerSecond = 50000000; // 50 Mbps for VP8
                }
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                    options.videoBitsPerSecond = 25000000; // 25 Mbps as fallback
                }
                
                mediaRecorder = new MediaRecorder(combinedStream, options);
                
                // Store chunks for post-processing
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                        if (writableStream) {
                            writableStream.write(event.data);
                        }
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    // Show processing overlay
                    processingOverlay.style.display = 'flex';
                    
                    // Create final blob from all chunks
                    const fullBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    
                    // Trim last 10 seconds
                    const trimmedBlob = await trimVideo(fullBlob);
                    
                    // Save trimmed video
                    if (writableStream) {
                        await writableStream.seek(0);
                        await writableStream.write(trimmedBlob);
                        await writableStream.close();
                        writableStream = null;
                        fileHandle = null;
                    }
                    
                    // Hide processing overlay
                    processingOverlay.style.display = 'none';
                    
                    statusText.textContent = 'Video processed and saved successfully';
                    setTimeout(() => {
                        if (stream) statusText.textContent = `Camera active - ${isFrontCamera ? 'Face marking mode' : 'Recording mode'}`;
                    }, 3000);
                    
                    video.muted = false;
                    recordedChunks = [];
                };
                
                // Function to draw viewfinder content to canvas
                function drawToCanvas() {
                    if (!isRecording) return;
                    
                    recordingCtx.save();
                    recordingCtx.translate(recordingCanvas.width / 2, recordingCanvas.height / 2);
                    recordingCtx.scale(currentZoom, currentZoom);
                    recordingCtx.translate(currentPanX * 50, currentPanY * 50);
                    recordingCtx.drawImage(
                        video, 
                        -recordingCanvas.width / 2, 
                        -recordingCanvas.height / 2, 
                        recordingCanvas.width, 
                        recordingCanvas.height
                    );
                    recordingCtx.restore();
                    
                    requestAnimationFrame(drawToCanvas);
                }
                
                mediaRecorder.start(1000);
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Start drawing to canvas
                drawToCanvas();
                
                recordButton.classList.add('recording');
                recordButton.innerHTML = '<span>‚èπÔ∏è</span>';
                recordingIndicator.style.display = 'flex';
                
                updateRecordingTimer();
                
                statusText.textContent = 'Recording - High Quality';
                
            } catch (error) {
                console.error('Error starting recording:', error);
                
                if (error.message.includes('File System Access API')) {
                    statusText.textContent = 'Recording requires Chrome/Edge browser';
                } else {
                    statusText.textContent = 'Error starting recording';
                }
                
                video.muted = false;
                if (writableStream) {
                    try {
                        await writableStream.close();
                    } catch (e) {}
                    writableStream = null;
                    fileHandle = null;
                }
            }
        }

        // Stop video recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                recordButton.classList.remove('recording');
                recordButton.innerHTML = '<span>‚è∫Ô∏è</span>';
                recordingIndicator.style.display = 'none';
                
                clearInterval(recordingInterval);
                
                video.muted = false;
            }
        }

        // Update recording timer
        function updateRecordingTimer() {
            if (!isRecording) return;
            
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            recordingTimer.textContent = `Recording ${minutes}:${seconds}`;
            recordingInterval = setTimeout(updateRecordingTimer, 1000);
        }

        // Set up UI auto-hide
        function setupUIHide() {
            outerFrame.addEventListener('mousemove', showUI);
            outerFrame.addEventListener('touchstart', showUI);
            
            hideUIAfterTimeout();
        }

        function showUI() {
            outerFrame.classList.remove('ui-hidden');
            clearTimeout(uiTimeout);
            hideUIAfterTimeout();
        }

        function hideUIAfterTimeout() {
            uiTimeout = setTimeout(() => {
                outerFrame.classList.add('ui-hidden');
            }, 3000);
        }

        // PWA Installation
        function setupPWA() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installButton.style.display = 'flex';
            });

            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    installButton.style.display = 'none';
                }
                
                deferredPrompt = null;
            });

            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('App launched in standalone mode');
            }
        }

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('SW registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Initialize the app
        window.addEventListener('load', init);

        // Set up camera toggle
        toggleCameraButton.addEventListener('click', toggleCamera);

        // Clean up
        window.addEventListener('beforeunload', () => {
            isTracking = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (isRecording) {
                stopRecording();
            }
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
        });
    </script>
</body>
</html>
