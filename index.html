<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="A simple and clean camera app.">
    <title>Camera</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 1;
            background: #000;
            transition: filter 0.5s ease-in-out;
        }

        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
            z-index: 10;
        }

        .control-btn {
            background: rgba(30, 30, 30, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 65px;
            height: 65px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            outline: none;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        #record {
            width: 80px;
            height: 80px;
        }

        #record.recording .record-icon {
            display: none;
        }

        #record:not(.recording) .stop-icon {
            display: none;
        }

        .status-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .status {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e53e3e;
        }

        .status-dot.active {
            background: #48bb78;
            animation: pulse 2s infinite;
        }

        .top-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-right-controls {
            display: flex;
            gap: 10px;
        }

        #handbook-btn, #settings-btn {
            width: 48px;
            height: 48px;
            padding: 10px;
        }

        .pwa-install {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            padding: 12px 18px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .pwa-install:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .recording-indicator {
            position: absolute;
            top: 80px; /* Adjusted position */
            left: 20px;
            background: rgba(220, 53, 69, 0.8);
            backdrop-filter: blur(20px);
            padding: 8px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            font-weight: 500;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: pulse 1.5s infinite;
        }

        /* Panel Styles */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
        }

        .panel-content {
            background: #1e1e1e;
            padding: 25px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .panel-content h2 {
            margin-bottom: 20px;
            text-align: center;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
        }

        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
        }

        .settings-group select {
            width: 100%;
            padding: 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 8px;
            color: #fff;
            font-size: 1rem;
        }

        .settings-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #48bb78;
        }

        .settings-group input[type="range"] {
            width: 100%;
        }

        .settings-group small {
            display: block;
            margin-top: 5px;
            color: #888;
            font-size: 0.8rem;
        }

        /* Handbook Styles */
        #handbook-content-container details {
            background: #2c2c2c;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        #handbook-content-container summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            outline: none;
        }
        #handbook-content-container .handbook-entry {
            padding: 0 15px 15px 15px;
            border-top: 1px solid #444;
        }
        #handbook-content-container .handbook-entry h4 {
            margin-top: 15px;
            color: #48bb78;
        }
        #handbook-content-container .handbook-entry p {
            color: #ccc;
            line-height: 1.6;
        }

        /* Focus Slider */
        .focus-slider-container {
            position: absolute;
            left: 30px;
            top: 50%;
            width: 240px;
            height: 40px;
            transform-origin: 0 0;
            transform: rotate(-90deg) translateX(-50%);
            z-index: 11;
            display: none; /* Hide completely if not supported */
            opacity: 0.3; /* Faded by default */
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .focus-slider-container.supported {
            display: block; /* Show if feature is supported */
        }

        .focus-slider-container.visible {
            opacity: 1; /* Fully visible and interactive in manual mode */
            pointer-events: all;
        }

        #focus-distance {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            margin: 0;
            padding: 0;
            cursor: pointer;
        }

        #focus-distance::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid rgba(0,0,0,0.5);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #focus-distance::-moz-range-thumb {
            width: 30px;
            height: 30px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid rgba(0,0,0,0.5);
        }

        /* Color Grading Filters */
        .grade-noir { filter: grayscale(1) contrast(1.2); }
        .grade-vintage { filter: sepia(0.6) contrast(1.05) brightness(1.05) saturate(1.1); }
        .grade-bleach-bypass { filter: contrast(1.4) saturate(0.5); }
        .grade-teal-orange { filter: contrast(1.05) saturate(1.2) sepia(.2) hue-rotate(-10deg); }
        .grade-matrix { filter: grayscale(1) contrast(1.2) brightness(0.9) sepia(1) hue-rotate(60deg) saturate(2.5); }
        .grade-kgf { filter: contrast(1.5) saturate(0.6) sepia(0.4) brightness(0.9); }
        .grade-salaar { filter: contrast(1.4) saturate(0.3) brightness(0.95) sepia(0.1) hue-rotate(10deg); }
        .grade-empuraan { filter: contrast(1.6) brightness(0.85) saturate(1.5) sepia(0.3) hue-rotate(-20deg); }
        .grade-meiyazhagan { filter: contrast(0.95) saturate(1.1) brightness(1.05) sepia(0.1); }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Hide UI elements when in fullscreen and no interaction */
        .container.ui-hidden .status-bar,
        .container.ui-hidden .controls,
        .container.ui-hidden .top-controls,
        .container.ui-hidden .recording-indicator,
        .container.ui-hidden .focus-slider-container {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .container:not(.ui-hidden) .status-bar,
        .container:not(.ui-hidden) .controls,
        .container:not(.ui-hidden) .top-controls,
        .container:not(.ui-hidden) .recording-indicator,
        .container:not(.ui-hidden) .focus-slider-container.visible {
            opacity: 1;
            transition: opacity 0.5s ease;
        }
    </style>
</head>

<body>
    <div class="container" id="container">
        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
        </div>

        <div class="status-bar">
            <div class="status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Initializing...</span>
            </div>
        </div>

        <div class="recording-indicator" id="recording-indicator" style="display: none;">
            <div class="recording-dot"></div>
            <span id="recording-timer">00:00</span>
        </div>

        <div class="top-controls">
            <button class="control-btn" id="handbook-btn" title="Filmmaking Handbook">
                <svg viewBox="0 0 24 24"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
            </button>
            <div class="top-right-controls">
                <div class="pwa-install" id="installButton" style="display: none;">
                    <span>⬇️</span> Install
                </div>
                <button class="control-btn" id="settings-btn" title="Settings">
                    <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
                </button>
            </div>
        </div>

        <div class="focus-slider-container" id="focus-slider-container">
            <input type="range" id="focus-distance" min="0" max="1" step="0.01">
        </div>

        <div class="controls">
            <button class="control-btn" id="toggle-camera" title="Switch Camera">
                <svg viewBox="0 0 24 24"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5L18.5 12 15 15.5z"/></svg>
            </button>
            <button class="control-btn" id="record" title="Record Video">
                <svg class="record-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="7" fill="#ff4545"/></svg>
                <svg class="stop-icon" viewBox="0 0 24 24"><rect x="8" y="8" width="8" height="8" rx="1" fill="#ff4545"/></svg>
            </button>
            <button class="control-btn" id="capture" title="Capture Photo">
                <svg viewBox="0 0 24 24"><path d="M12 12c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm0-10c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
        </div>
    </div>

    <!-- Handbook Panel -->
    <div class="panel-overlay" id="handbook-panel">
        <div class="panel-content">
            <button class="close-btn" id="close-handbook-btn">&times;</button>
            <h2>Filmmaking Handbook</h2>
            <div id="handbook-content-container"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="panel-overlay" id="settings-modal">
        <div class="panel-content">
            <button class="close-btn" id="close-settings-btn">&times;</button>
            <h2>Settings</h2>
            <div class="settings-group">
                <label for="aspect-ratio">Aspect Ratio</label>
                <select id="aspect-ratio"></select>
            </div>
            <div class="settings-group">
                <label for="color-grading">Color Grading</label>
                <select id="color-grading"></select>
            </div>
            <div class="settings-group" id="focus-control-group" style="display: none;">
                <label for="focus-mode">Focus Mode</label>
                <select id="focus-mode">
                    <option value="continuous">Continuous Autofocus</option>
                    <option value="manual">Manual</option>
                </select>
            </div>
            <div class="settings-group" id="video-stabilization-group" style="display: none;">
                <label for="video-stabilization">Video Stabilization</label>
                <select id="video-stabilization">
                    <option value="off">Off</option>
                    <option value="realtime">Real-time</option>
                    <option value="cinematic">Cinematic</option>
                </select>
            </div>
            <div class="settings-group" id="noise-suppression-group" style="display: none;">
                <label for="noise-suppression">
                    <input type="checkbox" id="noise-suppression">
                    Noise Suppression
                </label>
                <small>(Reduces background audio noise)</small>
            </div>
            <div class="settings-group">
                <label for="apply-grade-to-video">
                    <input type="checkbox" id="apply-grade-to-video">
                    Apply Grading to Video
                </label>
                <small>(May impact performance)</small>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const config = {
            aspectRatios: [
                { name: '16:9 (Widescreen TV)', value: 1.7777777778 },
                { name: '4:3 (Classic TV)', value: 1.3333333333 },
                { name: '1.85:1 (Cinematic Film)', value: 1.85 },
                { name: '2.39:1 (Anamorphic Scope)', value: 2.39 }
            ],
            colorGradings: [
                { name: 'None', value: 'none' },
                { name: 'Empuraan (Fiery Contrast)', value: 'empuraan' },
                { name: 'Meiyazhagan (Lush Nostalgia)', value: 'meiyazhagan' },
                { name: 'KGF (Gritty Warmth)', value: 'kgf' },
                { name: 'Salaar (Cool Despair)', value: 'salaar' },
                { name: 'Noir', value: 'noir' },
                { name: 'Vintage', value: 'vintage' },
                { name: 'Bleach Bypass', value: 'bleach-bypass' },
                { name: 'Teal & Orange', value: 'teal-orange' },
                { name: 'Matrix', value: 'matrix' }
            ]
        };

        // --- DOM ELEMENTS ---
        const video = document.getElementById('video');
        const container = document.getElementById('container');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const toggleCameraButton = document.getElementById('toggle-camera');
        const captureButton = document.getElementById('capture');
        const recordButton = document.getElementById('record');
        const recordingIndicator = document.getElementById('recording-indicator');
        const recordingTimer = document.getElementById('recording-timer');
        const installButton = document.getElementById('installButton');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const aspectRatioSelect = document.getElementById('aspect-ratio');
        const colorGradingSelect = document.getElementById('color-grading');
        const applyGradeCheckbox = document.getElementById('apply-grade-to-video');
        const handbookBtn = document.getElementById('handbook-btn');
        const handbookPanel = document.getElementById('handbook-panel');
        const closeHandbookBtn = document.getElementById('close-handbook-btn');
        const handbookContentContainer = document.getElementById('handbook-content-container');
        const videoStabilizationGroup = document.getElementById('video-stabilization-group');
        const videoStabilizationSelect = document.getElementById('video-stabilization');
        const focusControlGroup = document.getElementById('focus-control-group');
        const focusModeSelect = document.getElementById('focus-mode');
        const focusSliderContainer = document.getElementById('focus-slider-container');
        const focusDistanceSlider = document.getElementById('focus-distance');
        const noiseSuppressionGroup = document.getElementById('noise-suppression-group');
        const noiseSuppressionCheckbox = document.getElementById('noise-suppression');

        // --- APP STATE ---
        let stream = null;
        let currentFacingMode = 'environment';
        let currentAspectRatio = config.aspectRatios[0].value;
        let currentStabilizationMode = 'off';
        let currentFocusMode = 'continuous';
        let currentFocusDistance = 0;
        let enableNoiseSuppression = false;
        let applyGradeToVideo = false;
        let handbookContentLoaded = false;
        let optimalBitrate = 10000000; // Default bitrate
        let uiTimeout = null;
        let deferredPrompt = null;
        let wakeLock = null;

        // --- REAL-TIME PROCESSING STATE ---
        let canvas, canvasCtx, destinationStream, canvasLoopId = null;

        // --- VIDEO RECORDING STATE ---
        let mediaRecorder = null;
        let isRecording = false;
        let recordingStartTime = null;
        let recordingInterval = null;
        let fileHandle = null;
        let writableStream = null;

        // --- FUNCTIONS ---

        // Initialize the app
        async function init() {
            try {
                detectAndApplyDefaults();
                populateSelectOptions();
                await startCamera();
                setupPWA();
                setupUIHide();
                setupSettings();
                setupHandbook();
                setupWakeLock();
            } catch (error) {
                console.error('Error initializing app:', error);
                statusText.textContent = 'Error initializing app';
                statusDot.classList.remove('active');
            }
        }

        function detectAndApplyDefaults() {
            const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();

            if (supportedConstraints.noiseSuppression) {
                console.log('Noise suppression supported. Enabling by default.');
                enableNoiseSuppression = true;
                noiseSuppressionCheckbox.checked = true;
                noiseSuppressionGroup.style.display = 'block';
            }
            if (supportedConstraints.videoStabilizationMode) {
                console.log('Video stabilization control is supported.');
                videoStabilizationGroup.style.display = 'block';
            }
            if (supportedConstraints.focusMode && supportedConstraints.focusDistance) {
                console.log('Focus control is supported.');
                focusControlGroup.style.display = 'block';
                focusSliderContainer.classList.add('supported');
            }
        }

        // Populate dropdowns from config
        function populateSelectOptions() {
            config.aspectRatios.forEach(ratio => {
                const option = document.createElement('option');
                option.value = ratio.value;
                option.textContent = ratio.name;
                aspectRatioSelect.appendChild(option);
            });
            aspectRatioSelect.value = currentAspectRatio;

            config.colorGradings.forEach(grade => {
                const option = document.createElement('option');
                option.value = grade.value;
                option.textContent = grade.name;
                colorGradingSelect.appendChild(option);
            });
        }

        // Start camera
        async function startCamera() {
            statusText.textContent = 'Starting camera...';
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const audioConstraints = { noiseSuppression: enableNoiseSuppression };

            const videoConstraints = {
                width: { ideal: 10000 }, // Aim for max resolution
                height: { ideal: 10000 },
                aspectRatio: { exact: currentAspectRatio },
                facingMode: currentFacingMode
            };

            const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
            if (supportedConstraints.videoStabilizationMode && currentStabilizationMode !== 'off') {
                videoConstraints.videoStabilizationMode = currentStabilizationMode;
            }
            if (supportedConstraints.focusMode) {
                videoConstraints.focusMode = currentFocusMode;
            }

            const finalConstraints = { video: videoConstraints, audio: audioConstraints };

            try {
                stream = await navigator.mediaDevices.getUserMedia(finalConstraints);
            } catch (error) {
                console.error(`Constraint failed: ${error.name}`, error);
                alert(`A camera setting may not be fully supported. The app will use the closest available setting.`);
                delete finalConstraints.video.aspectRatio.exact;
                finalConstraints.video.aspectRatio.ideal = currentAspectRatio;
                try {
                    stream = await navigator.mediaDevices.getUserMedia(finalConstraints);
                } catch (fallbackError) {
                    console.error('Fallback camera start failed:', fallbackError);
                    statusText.textContent = 'Camera failed to start.';
                    return;
                }
            }

            const settings = stream.getVideoTracks()[0].getSettings();
            const width = settings.width;

            if (width >= 3840) {
                optimalBitrate = 40000000; // 40 Mbps for 4K
            } else if (width >= 1920) {
                optimalBitrate = 15000000; // 15 Mbps for 1080p
            } else if (width >= 1280) {
                optimalBitrate = 8000000;  // 8 Mbps for 720p
            } else {
                optimalBitrate = 4000000;  // 4 Mbps for lower resolutions
            }
            console.log(`Camera started with resolution ${width}x${settings.height}. Optimal bitrate set to ${optimalBitrate / 1000000} Mbps.`);

            video.srcObject = stream;
            video.muted = true;
            video.style.transform = currentFacingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';

            statusDot.classList.add('active');
            statusText.textContent = 'Ready';
        }

        function setupSettings() {
            // --- Event Listeners ---
            settingsBtn.addEventListener('click', () => {
                settingsModal.style.display = 'flex';
            });

            closeSettingsBtn.addEventListener('click', () => {
                settingsModal.style.display = 'none';
            });

            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    settingsModal.style.display = 'none';
                }
            });

            aspectRatioSelect.addEventListener('change', async () => {
                currentAspectRatio = parseFloat(aspectRatioSelect.value);
                await startCamera();
            });

            colorGradingSelect.addEventListener('change', () => {
                const selectedGrade = colorGradingSelect.value;
                video.classList.forEach(className => {
                    if (className.startsWith('grade-')) {
                        video.classList.remove(className);
                    }
                });
                if (selectedGrade !== 'none') {
                    video.classList.add(`grade-${selectedGrade}`);
                }
            });

            applyGradeCheckbox.addEventListener('change', () => {
                applyGradeToVideo = applyGradeCheckbox.checked;
            });

            videoStabilizationSelect.addEventListener('change', async () => {
                currentStabilizationMode = videoStabilizationSelect.value;
                await startCamera();
            });

            focusModeSelect.addEventListener('change', async () => {
                currentFocusMode = focusModeSelect.value;
                if (currentFocusMode === 'manual') {
                    focusSliderContainer.classList.add('visible');
                } else {
                    focusSliderContainer.classList.remove('visible');
                }
                await startCamera(); 
            });

            focusDistanceSlider.addEventListener('input', () => {
                currentFocusDistance = parseFloat(focusDistanceSlider.value);
                applyFocusSettings();
            });

            noiseSuppressionCheckbox.addEventListener('change', async () => {
                enableNoiseSuppression = noiseSuppressionCheckbox.checked;
                await startCamera();
            });
        }

        async function applyFocusSettings() {
            if (!stream || currentFocusMode !== 'manual') return;
            const track = stream.getVideoTracks()[0];
            const capabilities = track.getCapabilities();
            
            if (capabilities.focusDistance) {
                const min = capabilities.focusDistance.min || 0;
                const max = capabilities.focusDistance.max || 1;
                const scaledDistance = min + (currentFocusDistance * (max - min));
                
                try {
                    await track.applyConstraints({ advanced: [{ focusMode: 'manual', focusDistance: scaledDistance }] });
                } catch (error) {
                    console.error("Failed to apply focus distance:", error);
                }
            }
        }

        function setupHandbook() {
            handbookBtn.addEventListener('click', async () => {
                if (!handbookContentLoaded) {
                    try {
                        const response = await fetch('handbook.json');
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const data = await response.json();
                        populateHandbook(data);
                        handbookContentLoaded = true;
                    } catch (error) {
                        console.error('Failed to load handbook data:', error);
                        handbookContentContainer.innerHTML = '<p>Error: Could not load handbook.</p>';
                    }
                }
                handbookPanel.style.display = 'flex';
            });

            closeHandbookBtn.addEventListener('click', () => {
                handbookPanel.style.display = 'none';
            });

            handbookPanel.addEventListener('click', (e) => {
                if (e.target === handbookPanel) {
                    handbookPanel.style.display = 'none';
                }
            });
        }

        function populateHandbook(data) {
            handbookContentContainer.innerHTML = ''; // Clear previous content
            data.categories.forEach(category => {
                const details = document.createElement('details');
                const summary = document.createElement('summary');
                summary.textContent = category.title;
                
                const entryContainer = document.createElement('div');
                entryContainer.className = 'handbook-entry';

                category.entries.forEach(entry => {
                    const title = document.createElement('h4');
                    title.textContent = entry.name;
                    const description = document.createElement('p');
                    description.textContent = entry.description;
                    entryContainer.appendChild(title);
                    entryContainer.appendChild(description);
                });

                details.appendChild(summary);
                details.appendChild(entryContainer);
                handbookContentContainer.appendChild(details);
            });
        }

        function startCanvasProcessing() {
            if (!stream || canvas) return;
            const videoTrack = stream.getVideoTracks()[0];
            const settings = videoTrack.getSettings();

            canvas = document.createElement('canvas');
            canvas.width = settings.width;
            canvas.height = settings.height;
            canvasCtx = canvas.getContext('2d');

            destinationStream = canvas.captureStream();
            const audioTrack = stream.getAudioTracks()[0];
            if (audioTrack) {
                destinationStream.addTrack(audioTrack);
            }

            function canvasLoop() {
                if (!isRecording) { // Stop loop if recording stops
                    stopCanvasProcessing();
                    return;
                }
                canvasCtx.filter = getComputedStyle(video).filter;
                canvasCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
                canvasLoopId = requestAnimationFrame(canvasLoop);
            }
            canvasLoopId = requestAnimationFrame(canvasLoop);
        }

        function stopCanvasProcessing() {
            if (canvasLoopId) {
                cancelAnimationFrame(canvasLoopId);
                canvasLoopId = null;
            }
            destinationStream = null;
            canvas = null;
            canvasCtx = null;
        }

        // Capture photo
        captureButton.addEventListener('click', () => {
            if (!stream) return;

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');

            context.filter = getComputedStyle(video).filter;

            if (currentFacingMode === 'user') {
                context.translate(canvas.width, 0);
                context.scale(-1, 1);
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `camera-photo-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png', 0.95);
            link.click();

            statusText.textContent = 'Photo saved';
            setTimeout(() => { statusText.textContent = 'Ready'; }, 2000);
        });

        // Toggle recording
        recordButton.addEventListener('click', async () => {
            if (!stream) return;
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        });

        // Start video recording
        async function startRecording() {
            try {
                if (!('showSaveFilePicker' in window)) {
                    alert('Your browser does not support saving files directly. Please use Chrome or Edge on desktop.');
                    throw new Error('File System Access API not supported.');
                }

                statusText.textContent = 'Select save location...';
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `camera-video-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`,
                        types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
                    });
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('File picker error:', err);
                    statusText.textContent = 'Ready';
                    return;
                }

                let streamToRecord = stream;
                if (applyGradeToVideo) {
                    console.log("Applying color grade to video recording.");
                    startCanvasProcessing();
                    streamToRecord = destinationStream;
                } else {
                    console.log("Recording raw video without color grade.");
                }

                writableStream = await fileHandle.createWritable();
                const options = { mimeType: 'video/webm; codecs=vp9,opus', videoBitsPerSecond: optimalBitrate };
                mediaRecorder = new MediaRecorder(streamToRecord, options);

                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0 && writableStream) {
                        try {
                            await writableStream.write(event.data);
                        } catch (error) {
                            console.error('Error writing to file:', error);
                            stopRecording();
                        }
                    }
                };

                mediaRecorder.onstop = async () => {
                    if (writableStream) {
                        try {
                            await writableStream.close();
                        } catch (error) {
                            console.error('Error closing file:', error);
                        }
                    }
                    writableStream = null;
                    fileHandle = null;
                    statusText.textContent = 'Video saved';
                    setTimeout(() => { statusText.textContent = 'Ready'; }, 3000);
                };

                mediaRecorder.start(1000);
                isRecording = true;
                recordingStartTime = Date.now();

                recordButton.classList.add('recording');
                recordingIndicator.style.display = 'flex';
                updateRecordingTimer();
                statusText.textContent = 'Recording...';

            } catch (error) {
                console.error('Error starting recording:', error);
                statusText.textContent = 'Recording failed';
            }
        }

        // Stop video recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                if (applyGradeToVideo) {
                    stopCanvasProcessing();
                }
                recordButton.classList.remove('recording');
                recordingIndicator.style.display = 'none';
                clearInterval(recordingInterval);
            }
        }

        // Update recording timer
        function updateRecordingTimer() {
            if (!isRecording) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            recordingTimer.textContent = `${minutes}:${seconds}`;
            recordingInterval = setTimeout(updateRecordingTimer, 1000);
        }

        // Toggle camera (front/back if available)
        toggleCameraButton.addEventListener('click', async () => {
            if (!stream) return;
            currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
            await startCamera();
        });

        // Set up UI auto-hide
        function setupUIHide() {
            container.addEventListener('mousemove', showUI);
            container.addEventListener('touchstart', showUI);
            hideUIAfterTimeout();
        }

        function showUI() {
            container.classList.remove('ui-hidden');
            clearTimeout(uiTimeout);
            hideUIAfterTimeout();
        }

        function hideUIAfterTimeout() {
            uiTimeout = setTimeout(() => {
                if (!isRecording) { // Don't hide controls while recording
                    container.classList.add('ui-hidden');
                }
            }, 4000);
        }

        // PWA Installation & Wake Lock
        async function setupPWA() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installButton.style.display = 'flex';
            });
            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    installButton.style.display = 'none';
                }
                deferredPrompt = null;
            });
            if (window.matchMedia('(display-mode: standalone)').matches) {
                installButton.style.display = 'none';
            }
        }

        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock was released');
                    });
                    console.log('Screen Wake Lock is active');
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                }
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLock !== null) {
                await wakeLock.release();
                wakeLock = null;
            }
        };

        function setupWakeLock() {
            requestWakeLock();
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    await requestWakeLock();
                } else {
                    await releaseWakeLock();
                }
            });
        }

        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').catch(err => console.log('SW reg failed: ', err));
            });
        }

        // Initialize and clean up
        window.addEventListener('load', init);
        window.addEventListener('beforeunload', () => {
            releaseWakeLock();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (isRecording) {
                stopRecording();
            }
        });
    </script>
</body>

</html>